{
  "language": "Solidity",
  "sources": {
    "contracts/CxipAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./interface/ICxipERC721.sol\";\nimport \"./interface/ICxipIdentity.sol\";\nimport \"./interface/ICxipProvenance.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./library/Address.sol\";\nimport \"./struct/UriType.sol\";\n\n/**\n * @title CXIP Asset\n * @author CXIP-Labs\n * @notice A smart contract for providing a single entry for checking validity of collections and tokens minted through CXIP.\n * @dev Listen events broadcasted by this smart contract, to get all collections and NFT being minted with CXIP smart contracts.\n */\ncontract CxipAsset {\n    /**\n     * @dev Used for setting a default URI type to be returned in a tokenURI / URI calls from the ERC721 and ERC1155 smart contracts.\n     * @dev Convenient method for having a quick toggle in case a network (like Arweave) goes offline.\n     */\n    UriType private _defaultUri;\n\n    /**\n     * @dev Collections mapped to Identity smart contract addresses.\n     */\n    mapping(address => address) private _collectionIdentity;\n\n    /**\n     * @notice Event emitted when an existing collection is added to an Identity.\n     * @dev Emits event to record when an existing collection was added.\n     * @param collectionAddress Address of the collection smart contract.\n     * @param identityAddress Address of the identity smart contract.\n     */\n    event CollectionAdded(address indexed collectionAddress, address indexed identityAddress);\n\n    /**\n     * @notice Event emitted when a new collection is created and added to an Identity.\n     * @dev Emits event to record when a new collection is created.\n     * @param collectionAddress Address of the collection smart contract.\n     * @param identityAddress Address of the identity smart contract.\n     */\n    event CollectionCreated(address indexed collectionAddress, address indexed identityAddress);\n\n    /**\n     * @notice Event emitted when an existing token is added to an Identity.\n     * @dev Emits event to record when an existing token was added.\n     * @param collectionAddress Address of the collection smart contract.\n     * @param identityAddress Address of the identity smart contract.\n     * @param tokenId Id of the token being added.\n     */\n    event TokenAdded(\n        address indexed collectionAddress,\n        address indexed identityAddress,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @notice Event emitted when a new token is created and added to an Identity.\n     * @dev Emits event to record when a new token is created.\n     * @param collectionAddress Address of the collection smart contract.\n     * @param identityAddress Address of the identity smart contract.\n     * @param tokenId Id of the token being created.\n     */\n    event TokenCreated(\n        address indexed collectionAddress,\n        address indexed identityAddress,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @notice Constructor is empty and not utilised of anything but setting a default URI type.\n     * @dev Smart contract is being used as an on-chain ledger. Nothing needs to be configured.\n     */\n    constructor() {\n        _defaultUri = UriType.ARWEAVE;\n    }\n\n    /**\n     * @notice Associates the collection with an identity.\n     * @dev Contains logic to check if collection is new.\n     * @param creator The creator of the collection.\n     * @param collection The collection address.\n     * @param fresh A flag to certify the collection and will be used to implement copyright.\n     */\n    function AddCollection(\n        address creator,\n        address collection,\n        bool fresh\n    ) public {\n        address identityAddress = msg.sender;\n        require(\n            ICxipProvenance(getRegistry().getProvenance()).isIdentityValid(identityAddress),\n            \"CXIP: invalid Identity contract\"\n        );\n        ICxipIdentity identity = ICxipIdentity(identityAddress);\n        require(identity.isWalletRegistered(creator), \"CXIP: creator wallet not owner\");\n        require(identity.isCollectionRegistered(collection), \"CXIP: not registered collection\");\n        bool certified = false;\n        if (fresh) {\n            require(identity.isNew(), \"CXIP: not a new collection\");\n            certified = true;\n            emit CollectionCreated(collection, creator);\n        } else {\n            emit CollectionAdded(collection, creator);\n        }\n        _collectionIdentity[collection] = identityAddress;\n    }\n\n    /**\n     * @notice Adds a token to a collection.\n     * @dev Contains logic to check if token is new.\n     * @param creator Creator of the collection.\n     * @param collection Address of the collection.\n     * @param tokenId The token to be added to the collection.\n     * @param fresh A flag to certify the token and will be used to implement copyright.\n     */\n    function AddToken(\n        address creator,\n        address collection,\n        uint256 tokenId,\n        bool fresh\n    ) public {\n        address identityAddress = msg.sender;\n        require(\n            ICxipProvenance(getRegistry().getProvenance()).isIdentityValid(identityAddress),\n            \"CXIP: invalid Identity contract\"\n        );\n        ICxipIdentity identity = ICxipIdentity(identityAddress);\n        require(identity.isWalletRegistered(creator), \"CXIP: creator wallet not owner\");\n        require(identity.isCollectionRegistered(collection), \"CXIP: not registered collection\");\n        require(identity.isTokenRegistered(collection, tokenId), \"CXIP: not registered token\");\n        bool certified = false;\n        if (fresh) {\n            require(identity.isNew(), \"CXIP: not a new collection token\");\n            certified = true;\n            emit TokenCreated(collection, creator, tokenId);\n        } else {\n            emit TokenAdded(collection, creator, tokenId);\n        }\n    }\n\n    /**\n     * @notice Gets the type of URI (Arweave / IPFS / HTTP).\n     * @dev Uses an enum value from 0 - 2 for each type.\n     * @return UriType.\n     */\n    function defaultUriType() public view returns (UriType) {\n        return _defaultUri;\n    }\n\n    /**\n     * @notice Gets the identity associated with the collection.\n     * @dev Gets the address of the identity contract.\n     * @param collection The address of the collection.\n     * @return address of the identity contract.\n     */\n    function getCollectionIdentity(address collection) public view returns (address) {\n        ICxipIdentity identity = _getIdentity(collection);\n        return address(identity);\n    }\n\n    /**\n     * @notice Get the collection's Interface Type: ERC20, ERC721, ERC1155.\n     * @dev Collection must be associated with identity.\n     * @param collection Contract address of the collection.\n     * @return InterfaceType Returns an enum (uint8) of the collection interface type.\n     */\n    function getCollectionType(address collection) public view returns (InterfaceType) {\n        ICxipIdentity identity = _getIdentity(collection);\n        require(!Address.isZero(address(identity)), \"CXIP: not registered collection\");\n        return identity.getCollectionType(collection);\n    }\n\n    /**\n     * @dev Reserved function for later use. Will be used to identify if collection was heavily vetted.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with the identity.\n     */\n    function isCollectionCertified(address collection) public view returns (bool) {\n        ICxipIdentity identity = _getIdentity(collection);\n        if (Address.isZero(address(identity))) {\n            return false;\n        }\n        return identity.isCollectionCertified(collection);\n    }\n\n    /**\n     * @notice Check if an identity collection is open to external minting.\n     * @dev For now this always returns false. Left as a placeholder for future development where shared collections might be used.\n     * @dev Since it's not being used, the collection variable is commented out to avoid compiler warnings.\n     * @return bool Returns true of false, to indicate if a specific collection is open/shared.\n     */\n    function isCollectionOpen(address collection) public view returns (bool) {\n        ICxipIdentity identity = _getIdentity(collection);\n        if (Address.isZero(address(identity))) {\n            return false;\n        }\n        return identity.isCollectionOpen(collection);\n    }\n\n    /**\n     * @notice Check if a collection is registered with identity.\n     * @dev For now will only return true for collections created directly from the identity contract.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with the identity.\n     */\n    function isCollectionRegistered(address collection) public view returns (bool) {\n        ICxipIdentity identity = _getIdentity(collection);\n        if (Address.isZero(address(identity))) {\n            return false;\n        }\n        return identity.isCollectionRegistered(collection);\n    }\n\n    /**\n     * @dev Reserved function for later use. Will be used to identify if token was heavily vetted.\n     * @param collection Contract address of the collection.\n     * @param tokenId Id of the token.\n     * @return bool Returns true if token is associated with the identity.\n     */\n    function isTokenCertified(address collection, uint256 tokenId) public view returns (bool) {\n        ICxipIdentity identity = _getIdentity(collection);\n        if (Address.isZero(address(identity))) {\n            return false;\n        }\n        return identity.isTokenCertified(collection, tokenId);\n    }\n\n    /**\n     * @notice Check if a token is registered with identity.\n     * @dev For now will only return true for tokens created directly from the identity contract.\n     * @param collection Contract address of the collection.\n     * @param tokenId Id of the token.\n     * @return bool Returns true if token is associated with the identity.\n     */\n    function isTokenRegistered(address collection, uint256 tokenId) public view returns (bool) {\n        ICxipIdentity identity = _getIdentity(collection);\n        if (Address.isZero(address(identity))) {\n            return false;\n        }\n        return identity.isTokenRegistered(collection, tokenId);\n    }\n\n    /**\n     * @notice Gets the identity associated with the collection.\n     * @dev Returns zero address if identity doesn't exist.\n     * @param collection Collection associated with the identitiy.\n     * @return ICxipIdentity The identity interface.\n     */\n    function _getIdentity(address collection) internal view returns (ICxipIdentity) {\n        address identityAddress = _collectionIdentity[collection];\n        return ICxipIdentity(identityAddress);\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n    }\n}\n"
    },
    "contracts/interface/ICxipERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../struct/CollectionData.sol\";\nimport \"../struct/TokenData.sol\";\nimport \"../struct/Verification.sol\";\n\ninterface ICxipERC721 {\n    function arweaveURI(uint256 tokenId) external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    function creator(uint256 tokenId) external view returns (address);\n\n    function httpURI(uint256 tokenId) external view returns (string memory);\n\n    function ipfsURI(uint256 tokenId) external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function payloadHash(uint256 tokenId) external view returns (bytes32);\n\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory);\n\n    function payloadSigner(uint256 tokenId) external view returns (address);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    /* Disabled due to tokenEnumeration not enabled.\n    function tokensOfOwner(\n        address wallet\n    ) external view returns (uint256[] memory);\n    */\n\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function burn(uint256 tokenId) external;\n\n    function init(address newOwner, CollectionData calldata collectionData) external;\n\n    /* Disabled since this flow has not been agreed on.\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n    */\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable;\n\n    function setApprovalForAll(address to, bool approved) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable;\n\n    function cxipMint(uint256 id, TokenData calldata tokenData) external returns (uint256);\n\n    function setApprovalForAll(\n        address from,\n        address to,\n        bool approved\n    ) external;\n\n    function setName(bytes32 newName, bytes32 newName2) external;\n\n    function setSymbol(bytes32 newSymbol) external;\n\n    function transferOwnership(address newOwner) external;\n\n    /*\n    // Disabled due to tokenEnumeration not enabled.\n    function balanceOf(address wallet) external view returns (uint256);\n    */\n    function baseURI() external view returns (string memory);\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function getIdentity() external view returns (address);\n\n    function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n    function isOwner() external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    /* Disabled due to tokenEnumeration not enabled.\n    function tokenByIndex(uint256 index) external view returns (uint256);\n    */\n\n    /* Disabled due to tokenEnumeration not enabled.\n    function tokenOfOwnerByIndex(\n        address wallet,\n        uint256 index\n    ) external view returns (uint256);\n    */\n\n    /* Disabled due to tokenEnumeration not enabled.\n    function totalSupply() external view returns (uint256);\n    */\n\n    function totalSupply() external view returns (uint256);\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external pure returns (bytes4);\n}\n"
    },
    "contracts/interface/ICxipIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../struct/CollectionData.sol\";\nimport \"../struct/InterfaceType.sol\";\nimport \"../struct/Token.sol\";\nimport \"../struct/TokenData.sol\";\n\ninterface ICxipIdentity {\n    function addSignedWallet(\n        address newWallet,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function addWallet(address newWallet) external;\n\n    function connectWallet() external;\n\n    function createERC721Token(\n        address collection,\n        uint256 id,\n        TokenData calldata tokenData,\n        Verification calldata verification\n    ) external returns (uint256);\n\n    function createERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData\n    ) external returns (address);\n\n    function createCustomERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData,\n        bytes32 slot,\n        bytes memory bytecode\n    ) external returns (address);\n\n    function init(address wallet, address secondaryWallet) external;\n\n    function getAuthorizer(address wallet) external view returns (address);\n\n    function getCollectionById(uint256 index) external view returns (address);\n\n    function getCollectionType(address collection) external view returns (InterfaceType);\n\n    function getWallets() external view returns (address[] memory);\n\n    function isCollectionCertified(address collection) external view returns (bool);\n\n    function isCollectionRegistered(address collection) external view returns (bool);\n\n    function isNew() external view returns (bool);\n\n    function isOwner() external view returns (bool);\n\n    function isTokenCertified(address collection, uint256 tokenId) external view returns (bool);\n\n    function isTokenRegistered(address collection, uint256 tokenId) external view returns (bool);\n\n    function isWalletRegistered(address wallet) external view returns (bool);\n\n    function listCollections(uint256 offset, uint256 length)\n        external\n        view\n        returns (address[] memory);\n\n    function nextNonce(address wallet) external view returns (uint256);\n\n    function totalCollections() external view returns (uint256);\n\n    function isCollectionOpen(address collection) external pure returns (bool);\n}\n"
    },
    "contracts/interface/ICxipProvenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface ICxipProvenance {\n    function createIdentity(\n        bytes32 saltHash,\n        address wallet,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256, address);\n\n    function createIdentityBatch(\n        bytes32 saltHash,\n        address[] memory wallets,\n        uint8[] memory V,\n        bytes32[] memory RS\n    ) external returns (uint256, address);\n\n    function getIdentity() external view returns (address);\n\n    function getWalletIdentity(address wallet) external view returns (address);\n\n    function informAboutNewWallet(address newWallet) external;\n\n    function isIdentityValid(address identity) external view returns (bool);\n\n    function nextNonce(address wallet) external view returns (uint256);\n}\n"
    },
    "contracts/interface/ICxipRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface ICxipRegistry {\n    function getAsset() external view returns (address);\n\n    function getAssetSigner() external view returns (address);\n\n    function getAssetSource() external view returns (address);\n\n    function getCopyright() external view returns (address);\n\n    function getCopyrightSource() external view returns (address);\n\n    function getCustomSource(bytes32 name) external view returns (address);\n\n    function getCustomSourceFromString(string memory name) external view returns (address);\n\n    function getERC1155CollectionSource() external view returns (address);\n\n    function getERC721CollectionSource() external view returns (address);\n\n    function getIdentitySource() external view returns (address);\n\n    function getPA1D() external view returns (address);\n\n    function getPA1DSource() external view returns (address);\n\n    function getProvenance() external view returns (address);\n\n    function getProvenanceSource() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function setAsset(address proxy) external;\n\n    function setAssetSigner(address source) external;\n\n    function setAssetSource(address source) external;\n\n    function setCopyright(address proxy) external;\n\n    function setCopyrightSource(address source) external;\n\n    function setCustomSource(string memory name, address source) external;\n\n    function setERC1155CollectionSource(address source) external;\n\n    function setERC721CollectionSource(address source) external;\n\n    function setIdentitySource(address source) external;\n\n    function setPA1D(address proxy) external;\n\n    function setPA1DSource(address source) external;\n\n    function setProvenance(address proxy) external;\n\n    function setProvenanceSource(address source) external;\n}\n"
    },
    "contracts/library/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != 0x0 &&\n            codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n    }\n\n    function isZero(address account) internal pure returns (bool) {\n        return (account == address(0));\n    }\n}\n"
    },
    "contracts/struct/UriType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\n// This is a 256 value limit (uint8)\nenum UriType {\n    ARWEAVE, // 0\n    IPFS, // 1\n    HTTP // 2\n}\n"
    },
    "contracts/struct/CollectionData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./UriType.sol\";\n\nstruct CollectionData {\n    bytes32 name;\n    bytes32 name2;\n    bytes32 symbol;\n    address royalties;\n    uint96 bps;\n}\n"
    },
    "contracts/struct/TokenData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./Verification.sol\";\n\nstruct TokenData {\n    bytes32 payloadHash;\n    Verification payloadSignature;\n    address creator;\n    bytes32 arweave;\n    bytes11 arweave2;\n    bytes32 ipfs;\n    bytes14 ipfs2;\n}\n"
    },
    "contracts/struct/Verification.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nstruct Verification {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n}\n"
    },
    "contracts/struct/InterfaceType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\n// This is a 256 value limit (uint8)\nenum InterfaceType {\n    NULL, // 0\n    ERC20, // 1\n    ERC721, // 2\n    ERC1155 // 3\n}\n"
    },
    "contracts/struct/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./InterfaceType.sol\";\n\nstruct Token {\n    address collection;\n    uint256 tokenId;\n    InterfaceType tokenType;\n    address creator;\n}\n"
    },
    "contracts/interface/ICxipAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../struct/InterfaceType.sol\";\nimport \"../struct/UriType.sol\";\n\ninterface ICxipAsset {\n    function AddCollection(\n        address creator,\n        address collection,\n        bool fresh\n    ) external;\n\n    function AddToken(\n        address creator,\n        address collection,\n        uint256 tokenId,\n        bool fresh\n    ) external;\n\n    function defaultUriType() external view returns (UriType);\n\n    function getCollectionIdentity(address collection) external view returns (address);\n\n    function getCollectionType(address collection) external view returns (InterfaceType);\n\n    function isCollectionCertified(address collection) external view returns (bool);\n\n    function isCollectionOpen(address collection) external view returns (bool);\n\n    function isCollectionRegistered(address collection) external view returns (bool);\n\n    function isTokenCertified(address collection, uint256 tokenId) external view returns (bool);\n\n    function isTokenRegistered(address collection, uint256 tokenId) external view returns (bool);\n}\n"
    },
    "contracts/struct/CollectionInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./InterfaceType.sol\";\n\nstruct CollectionInfo {\n    InterfaceType interfaceType;\n    bool valid;\n    bool open;\n    bool certified;\n}\n"
    },
    "contracts/CxipIdentity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./interface/ICxipERC721.sol\";\nimport \"./interface/ICxipProvenance.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./library/Address.sol\";\nimport \"./library/Signature.sol\";\nimport \"./struct/CollectionData.sol\";\nimport \"./struct/InterfaceType.sol\";\nimport \"./struct/Token.sol\";\nimport \"./struct/TokenData.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title CXIP Identity\n * @author CXIP-Labs\n * @notice A smart contract for managing an on-chain identity.\n * @dev The smart contract interacts and relies on CXIP Provenance.\n */\ncontract CxipIdentity {\n    /**\n     * @dev A variable that is used as an external indicator.\n     */\n    bool private _newTrigger;\n    /**\n     * @dev Array of all wallets associated with the identity.\n     */\n    address[] private _walletArray;\n    /**\n     * @dev Array of addresses for all collection that were created by the identity.\n     */\n    address[] private _collectionArray;\n    /**\n     * @dev Temporary map for storing wallets that need to be added, but have not been authorised yet.\n     */\n    mapping(address => address) private _preAuthWallets;\n    /**\n     * @dev A map of nonces already used by a wallet, to prevent signature hijacking.\n     */\n    mapping(address => uint256) private _lastNonce;\n    /**\n     * @dev A map to make it possible for retrieving wallets by address rather than array index.\n     */\n    mapping(address => uint256) private _walletIndexMap;\n    /**\n     * @dev Map with interface type definitions for identity created collections.\n     */\n    mapping(address => InterfaceType) private _additionalInfo;\n\n    /**\n     * @dev Reentrancy implementation from OpenZepellin. State 1 == NOT_ENDERED, State 2 == ENTERED\n     */\n    uint256 private _reentrancyState;\n\n    /**\n     * @notice Constructor is empty and only reentrancy guard is implemented.\n     * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n     */\n    constructor() {\n        _reentrancyState = 1;\n    }\n\n    /**\n     * @notice Enables royaltiy functionality at the ERC721 level when ether is sent with no calldata.\n     * @dev See implementation of _royaltiesFallback.\n     */\n    receive() external payable {\n        _royaltiesFallback();\n    }\n\n    /**\n     * @notice Enables royaltiy functionality at the ERC721 level no other function matches the call.\n     * @dev See implementation of _royaltiesFallback.\n     */\n    fallback() external {\n        _royaltiesFallback();\n    }\n\n    /**\n     * @dev Implementation from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\n     */\n    modifier nonReentrant() {\n        require(_reentrancyState != 2, \"ReentrancyGuard: reentrant call\");\n        _reentrancyState = 2;\n        _;\n        _reentrancyState = 1;\n    }\n\n    /**\n     * @notice Check if an identity collection is open to external minting.\n     * @dev For now this always returns false. Left as a placeholder for future development where shared collections might be used.\n     * @dev Since it's not being used, the collection variable is commented out to avoid compiler warnings.\n     * @return bool Returns true of false, to indicate if a specific collection is open/shared.\n     */\n    function isCollectionOpen(\n        address/* collection*/\n    ) external pure returns (bool) {\n        return false;\n    }\n\n    /**\n     * @notice Add a new wallet to the identity.\n     * @dev This function needs to be called by a wallet already associated with the identity.\n     * @dev Signature from new wallet can be included or omitted. If not included, new wallet will need to make a connectWallet function call.\n     * @param newWallet Address of new wallet being added to the identity.\n     * @param v The V value of the new wallet signature (27-28). Optional.\n     * @param r The R value of the new wallet signature. Optional.\n     * @param s The S value of the new wallet signature. Optional.\n     */\n    function addSignedWallet(\n        address newWallet,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public nonReentrant {\n        require(_isOwner(msg.sender), \"CXIP: you are not an the owner\");\n        require(!Address.isContract(newWallet), \"CXIP: contract not allowed\");\n        require(\n            Address.isZero(\n                ICxipProvenance(\n                    getRegistry().getProvenance()\n                ).getWalletIdentity(newWallet)\n            ),\n            \"CXIP: wallet already registered\"\n        );\n        if(\n            r != 0x00\n            && s != 0x0000000000000000000000000000000000000000000000000000000000000000\n            && v != 0x0000000000000000000000000000000000000000000000000000000000000000\n        ) {\n            uint256 nonce = nextNonce(newWallet);\n            bytes memory encoded = abi.encodePacked(\n                address(this),\n                newWallet,\n                nonce\n            );\n            bool validSig = Signature.Valid(newWallet, r, s, v, encoded);\n            require(validSig, \"CXIP: invalid signature\");\n            _lastNonce[newWallet] = nonce;\n            _addWalletToEnumeration(newWallet);\n            ICxipProvenance(\n                getRegistry().getProvenance()\n            ).informAboutNewWallet(newWallet);\n        } else {\n            _preAuthWallets[newWallet] = msg.sender;\n        }\n    }\n\n    /**\n     * @notice Short-hand for addSignedWallet, but without the signature.\n     * @dev Use this function if you are not planning to include wallet signature.\n     * @param newWallet Address of new wallet being added to the identity.\n     */\n    function addWallet(address newWallet) public {\n        addSignedWallet(newWallet, 0, 0, 0);\n    }\n\n    /**\n     * @notice Connects a pre-authorised wallet.\n     * @dev Make this call with a new wallet after an addWallet function is called by an existing wallet.\n     */\n    function connectWallet() public nonReentrant {\n        address newWallet = msg.sender;\n        address authorizer = _preAuthWallets[newWallet];\n        require(!Address.isZero(authorizer), \"CXIP: not authorized by owner\");\n        require(_isOwner(authorizer), \"CXIP: authorizer no longer owner\");\n        require(\n            Address.isZero(\n                ICxipProvenance(\n                    getRegistry().getProvenance()\n                ).getWalletIdentity(newWallet)\n            ),\n            \"CXIP: wallet already registered\"\n        );\n        _addWalletToEnumeration(newWallet);\n        ICxipProvenance(getRegistry().getProvenance()).informAboutNewWallet(\n            newWallet\n        );\n        delete _preAuthWallets[newWallet];\n    }\n\n    /**\n     * @notice Create an ERC721 NFT for a collection created by this identity.\n     * @dev This function is embedded inside of the identity contract to make validation and providence bulletproof.\n     * @dev An NFT can be minted directly inside the collection, but the CXIP Asset smart contract will not mark it as a certified NFT.\n     * @param collection Address of the smart contract for the collection. Must have been created by this identity.\n     * @param id Token id for the NFT to mint. Can be left as 0 to allow automatic token id allocation.\n     * @param tokenData A struct containing all of the necessary NFT information.\n     * @param verification A verification signature issued by the CXIP Asset Signer as a guarantee of a valid NFT.\n     * @return uint256 Returns the token id of the newly minted NFT.\n     */\n    function createERC721Token(\n        address collection,\n        uint256 id,\n        TokenData calldata tokenData,\n        Verification calldata verification\n    ) public nonReentrant returns (uint256) {\n        require(_isOwner(msg.sender), \"CXIP: you are not an the owner\");\n        require(_isOwner(tokenData.creator), \"CXIP: creator not owner\");\n        require(\n            _additionalInfo[collection] == InterfaceType.ERC721,\n            \"CXIP: collection not ERC721\"\n        );\n        bytes memory encoded = abi.encodePacked(\n            address(this),\n            tokenData.creator,\n            collection,\n            id,\n            tokenData.payloadHash,\n            tokenData.payloadSignature.r,\n            tokenData.payloadSignature.s,\n            tokenData.payloadSignature.v,\n            tokenData.arweave,\n            tokenData.arweave2,\n            tokenData.ipfs,\n            tokenData.ipfs2\n        );\n        require(Signature.Valid(\n            getRegistry().getAssetSigner(),\n            verification.r,\n            verification.s,\n            verification.v,\n            encoded\n        ), \"CXIP: invalid signature\");\n        return ICxipERC721(collection).cxipMint(id, tokenData);\n    }\n\n    /**\n     * @notice Create an ERC721 collection.\n     * @dev Creates and associates the ERC721 collection with the identity.\n     * @param saltHash A salt used for deploying a collection to a specific address.\n     * @param collectionCreator Specific wallet, associated with the identity, that will be marked as the creator of this collection.\n     * @param verification Signature created by the collectionCreator wallet to validate the integrity of the collection data.\n     * @param collectionData The collection data struct, with all the default collection info.\n     * @return address Returns the address of the newly created collection.\n     */\n    function createERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData\n    ) public nonReentrant returns (address) {\n        if(collectionCreator != msg.sender) {\n            require(\n                Signature.Valid(\n                    collectionCreator,\n                    verification.r,\n                    verification.s,\n                    verification.v,\n                    abi.encodePacked(\n                        address(this),\n                        collectionCreator,\n                        collectionData.name,\n                        collectionData.name2,\n                        collectionData.symbol,\n                        collectionData.royalties,\n                        collectionData.bps\n                    )\n                ),\n                \"CXIP: invalid signature\"\n            );\n        }\n        require(_isOwner(collectionCreator), \"CXIP: creator not owner\");\n        bytes memory bytecode = hex\"608060405234801561001057600080fd5b50610128806100206000396000f3fe608060408190527f58bfd99600000000000000000000000000000000000000000000000000000000815260009073deaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD906358bfd9969060849060209060048186803b158015605f57600080fd5b505afa1580156072573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906094919060b9565b90503660008037600080366000845af43d6000803e80801560b4573d6000f35b3d6000fd5b60006020828403121560c9578081fd5b815173ffffffffffffffffffffffffffffffffffffffff8116811460eb578182fd5b939250505056fea2646970667358221220e40db164da39a10669859af903c7c9d1a96e3a2e162855f6b00aa89d483e4c6164736f6c63430008040033\";\n        address cxipAddress;\n        assembly {\n            cxipAddress := create2(\n                0,\n                add(bytecode, 0x20),\n                mload(bytecode),\n                saltHash\n            )\n        }\n        ICxipERC721(cxipAddress).init(collectionCreator, collectionData);\n        _addCollectionToEnumeration(cxipAddress, InterfaceType.ERC721);\n        return(cxipAddress);\n    }\n\n    /**\n     * @notice Create a custom ERC721 collection.\n     * @dev Creates and associates the custom ERC721 collection with the identity.\n     * @param saltHash A salt used for deploying a collection to a specific address.\n     * @param collectionCreator Specific wallet, associated with the identity, that will be marked as the creator of this collection.\n     * @param verification Signature created by the collectionCreator wallet to validate the integrity of the collection data.\n     * @param collectionData The collection data struct, with all the default collection info.\n     * @param slot Hash of proxy contract slot where the source is saved in registry.\n     * @param bytecode The bytecode used for deployment. Validated against slot code for abuse prevention.\n     * @return address Returns the address of the newly created collection.\n     */\n    function createCustomERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData,\n        bytes32 slot,\n        bytes memory bytecode\n    ) public nonReentrant returns (address) {\n        if(collectionCreator != msg.sender) {\n            require(\n                Signature.Valid(\n                    collectionCreator,\n                    verification.r,\n                    verification.s,\n                    verification.v,\n                    abi.encodePacked(\n                        address(this),\n                        collectionCreator,\n                        collectionData.name,\n                        collectionData.name2,\n                        collectionData.symbol,\n                        collectionData.royalties,\n                        collectionData.bps\n                    )\n                ),\n                \"CXIP: invalid signature\"\n            );\n        }\n        require(_isOwner(collectionCreator), \"CXIP: creator not owner\");\n        address cxipAddress;\n        assembly {\n            cxipAddress := create2(\n                0,\n                add(bytecode, 0x20),\n                mload(bytecode),\n                saltHash\n            )\n        }\n        require(\n            keccak256(cxipAddress.code) == keccak256(ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512).getCustomSource(slot).code),\n            \"CXIP: byte code missmatch\"\n        );\n        ICxipERC721(cxipAddress).init(collectionCreator, collectionData);\n        _addCollectionToEnumeration(cxipAddress, InterfaceType.ERC721);\n        return(cxipAddress);\n    }\n\n    /**\n     * @notice Initialise the identity. This function works only once.\n     * @dev It is important to run this inside the same function as the create2 for this contract.\n     * @param wallet The address of the wallet to add to new identity.\n     * @param secondaryWallet Optional second wallet to add to new identity.\n     */\n    function init(address wallet, address secondaryWallet) public nonReentrant {\n        require(_walletArray.length == 0, \"CXIP: already initialized\");\n        _addWalletToEnumeration(wallet);\n        if(!Address.isZero(secondaryWallet)) {\n            _addWalletToEnumeration(secondaryWallet);\n        }\n    }\n\n    /**\n     * @notice Returns the wallet that is authorising the new wallet to be added.\n     * @dev Should be used for visual validation of wallet that is authorising a new wallet to be added.\n     * @param wallet The address of the new wallet being requested to add.\n     * @return address Returns the address of the wallet that is requesting the new wallet.\n     */\n    function getAuthorizer(address wallet) public view returns (address) {\n        return _preAuthWallets[wallet];\n    }\n\n    /**\n     * @dev This retrieves a collection by index. Don't be confused by the ID in the title.\n     * @param index Index of the item to get from the array.\n     * @return address Returns the collection contract address at that index of array.\n     */\n    function getCollectionById(uint256 index) public view returns (address) {\n        return _collectionArray[index];\n    }\n\n    /**\n     * @notice Get the collection's Interface Type: ERC20, ERC721, ERC1155.\n     * @dev Collection must be associated with identity.\n     * @param collection Contract address of the collection.\n     * @return InterfaceType Returns an enum (uint8) of the collection interface type.\n     */\n    function getCollectionType(address collection) public view returns (InterfaceType) {\n        return _additionalInfo[collection];\n    }\n\n    /**\n     * @notice Get wallets associated with identity.\n     * @dev Any wallet returned in this response should be considered as owner.\n     * @return address[] Returns an array of all the wallets that have been associated with the identity contract..\n     */\n    function getWallets() public view returns (address[] memory) {\n        return _walletArray;\n    }\n\n    /**\n     * @dev Reserved function for later use. Will be used to identify if collection was heavily vetted.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with the identity.\n     */\n    function isCollectionCertified(\n        address collection\n    ) public view returns (bool) {\n        return _isCollectionValid(collection);\n    }\n\n    /**\n     * @notice Check if a collection is registered with identity.\n     * @dev For now will only return true for collections created directly from the identity contract.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with the identity.\n     */\n    function isCollectionRegistered(\n        address collection\n    ) public view returns (bool) {\n        return _isCollectionValid(collection);\n    }\n\n    /**\n     * @notice Used for cross-contract confirmation/validation. You should not use this.\n     * @dev This function is called by provenance as an extra layer of validation.\n     * @return bool Returns the current state of the _newTrigger variable.\n     */\n    function isNew() public view returns (bool) {\n        return _newTrigger;\n    }\n\n    /**\n     * @notice Check if current caller is owner of the smart contract.\n     * @dev This checks if the msg.sender wallet is associated with the identity.\n     * @return bool Returns true is the wallet is authorised by the identity.\n     */\n    function isOwner() public view returns (bool) {\n        return isWalletRegistered(msg.sender);\n    }\n\n    /**\n     * @dev Reserved function for later use. Will be used to identify if token was heavily vetted.\n     * @param collection Contract address of the collection.\n     * @param tokenId Id of the token.\n     * @return bool Returns true if token is associated with the identity.\n     */\n    function isTokenCertified(\n        address collection,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return _isValidToken(collection, tokenId);\n    }\n\n    /**\n     * @notice Check if a token is registered with identity.\n     * @dev For now will only return true for tokens created directly from the identity contract.\n     * @param collection Contract address of the collection.\n     * @param tokenId Id of the token.\n     * @return bool Returns true if token is associated with the identity.\n     */\n    function isTokenRegistered(\n        address collection,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return _isValidToken(collection, tokenId);\n    }\n\n    /**\n     * @notice Check if wallet is associated with the identity.\n     * @dev Used for external validation. Wallets can only be associated to one identity, ever.\n     * @param wallet Address of wallet to check against the identity.\n     * @return bool Returns true if wallet is registered to this identity.\n     */\n    function isWalletRegistered(address wallet) public view returns (bool) {\n        return _isOwner(wallet);\n    }\n\n    /**\n     * @notice List all collections associated with this identity.\n     * @dev Use in conjunction with the totalCollections function, for pagination.\n     * @param offset Index from where to start pagination. Start at 0.\n     * @param length Length of slice to return, starting from offset index.\n     * @return address[] Returns a fixed length array starting from offset.\n     */\n    function listCollections(\n        uint256 offset,\n        uint256 length\n    ) public view returns (address[] memory) {\n        uint256 limit = offset + length;\n        if(limit > _collectionArray.length) {\n            limit = _collectionArray.length;\n        }\n        address[] memory collections = new address[](limit - offset);\n        uint256 n = 0;\n        for(uint256 i = offset; i < limit; i++) {\n            collections[n] = _collectionArray[i];\n            n++;\n        }\n        return collections;\n    }\n\n    /**\n     * @notice Get next nonce to be used for a particular wallet.\n     * @dev This is not wallet transaction nonce. This is an internal nonce handled by the smart contract. Should be used for special instances where nonced signatures are required.\n     * @param wallet Address of wallet.\n     * @return uint256 Returns the next nonce to use.\n     */\n    function nextNonce(address wallet) public view returns (uint256) {\n        uint256 nonce = _lastNonce[wallet];\n        return nonce + 1;\n    }\n\n    /**\n     * @notice Get total number of collections associated with this identity.\n     * @dev Use in conjunction with the listCollections, for pagination.\n     * @return uint256 Returns the total length of collections.\n     */\n    function totalCollections() public view returns (uint256) {\n        return _collectionArray.length;\n    }\n\n    /**\n     * @dev Add collection to identity.\n     * @param collection Contract address of the collection to add.\n     * @param collectionType Interface type of the collection being added.\n     */\n    function _addCollectionToEnumeration(\n        address collection,\n        InterfaceType collectionType\n    ) internal {\n        _collectionArray.push(collection);\n        _additionalInfo[collection] = collectionType;\n    }\n\n    /**\n     * @dev Add wallet to identity.\n     * @param wallet Address of wallet to add.\n     */\n    function _addWalletToEnumeration(address wallet) internal {\n        uint256 index = _walletArray.length;\n        _walletArray.push(wallet);\n        _walletIndexMap[wallet] = index;\n    }\n\n    /**\n     * @dev Remove collection from identity.\n     * @param index Array index of the collection to remove.\n     */\n    function _removeCollectionFromEnumeration(uint256 index) internal {\n        require(\n            _collectionArray.length != 0,\n            \"CXIP: removing from empty array\"\n        );\n        delete _additionalInfo[_collectionArray[index]];\n        uint256 lastIndex = _collectionArray.length - 1;\n        if(lastIndex != 0) {\n            if(index != lastIndex) {\n                address lastCollection = _collectionArray[lastIndex];\n                _collectionArray[index] = lastCollection;\n            }\n        }\n        if(lastIndex == 0) {\n            delete _collectionArray;\n        } else {\n            delete _collectionArray[lastIndex];\n        }\n    }\n\n    /**\n     * @dev Remove wallet from identity.\n     * @param wallet Address of wallet to remove.\n     */\n    function _removeWalletFromEnumeration(address wallet) internal {\n        require(_walletArray.length != 0, \"CXIP: removing from empty array\");\n        uint256 lastIndex = _walletArray.length - 1;\n        require(lastIndex != 0, \"CXIP: cannot remove last wallet\");\n        uint256 walletIndex = _walletIndexMap[wallet];\n        if(walletIndex != lastIndex) {\n            address lastWallet = _walletArray[lastIndex];\n            _walletArray[walletIndex] = lastWallet;\n            _walletIndexMap[lastWallet] = walletIndex;\n        }\n        delete _walletArray[lastIndex];\n        delete _walletIndexMap[wallet];\n    }\n\n    /**\n     * @notice Allows retrieval of royalties from the contract.\n     * @dev This is a default fallback to ensure the royalties are available.\n     */\n    function _royaltiesFallback() internal {\n        address _target = getRegistry().getPA1D();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Check if collection is associated with this identity.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with this identity.\n     */\n    function _isCollectionValid(\n        address collection\n    ) internal view returns (bool) {\n        return _additionalInfo[collection] != InterfaceType.NULL;\n    }\n\n    /**\n     * @dev Check if wallet is associated with this identity.\n     * @param wallet Address of the wallet.\n     * @return bool Returns true if wallet is associated with this identity.\n     */\n    function _isOwner(address wallet) internal view returns (bool) {\n        return _walletArray[_walletIndexMap[wallet]] == wallet;\n    }\n\n    /**\n     * @dev Check if token is associated with this identity.\n     * @param collection Contract address of the collection.\n     * @dev Since it's not being used yet, the tokenId variable is commented out to avoid compiler warnings.\n     * @return bool Returns true if token is associated with this identity.\n     */\n    function _isValidToken(\n        address collection,\n        uint256/* tokenId*/\n    ) internal view returns (bool) {\n        return _additionalInfo[collection] != InterfaceType.NULL;\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n    }\n}\n"
    },
    "contracts/library/Signature.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Signature {\n    function Derive(\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        bytes memory encoded\n    )\n        internal\n        pure\n        returns (\n            address derived1,\n            address derived2,\n            address derived3,\n            address derived4\n        )\n    {\n        bytes32 encoded32;\n        assembly {\n            encoded32 := mload(add(encoded, 32))\n        }\n        derived1 = ecrecover(encoded32, v, r, s);\n        derived2 = ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)),\n            v,\n            r,\n            s\n        );\n        encoded32 = keccak256(encoded);\n        derived3 = ecrecover(encoded32, v, r, s);\n        encoded32 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32));\n        derived4 = ecrecover(encoded32, v, r, s);\n    }\n\n    function PackMessage(bytes memory encoded, bool geth) internal pure returns (bytes32) {\n        bytes32 hash = keccak256(encoded);\n        if (geth) {\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        }\n        return hash;\n    }\n\n    function Valid(\n        address target,\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        bytes memory encoded\n    ) internal pure returns (bool) {\n        bytes32 encoded32;\n        address derived;\n        if (encoded.length == 32) {\n            assembly {\n                encoded32 := mload(add(encoded, 32))\n            }\n            derived = ecrecover(encoded32, v, r, s);\n            if (target == derived) {\n                return true;\n            }\n            derived = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)),\n                v,\n                r,\n                s\n            );\n            if (target == derived) {\n                return true;\n            }\n        }\n        bytes32 hash = keccak256(encoded);\n        derived = ecrecover(hash, v, r, s);\n        if (target == derived) {\n            return true;\n        }\n        hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        derived = ecrecover(hash, v, r, s);\n        return target == derived;\n    }\n}\n"
    },
    "contracts/struct/MintData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./Verification.sol\";\n\nstruct MintData {\n    uint256 id;\n    bytes32 payloadHash;\n    Verification payloadSig;\n    bytes32 arweave;\n    bytes11 arweave2;\n    bytes32 ipfs;\n    bytes14 ipfs2;\n}\n"
    },
    "contracts/CxipProvenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./interface/ICxipIdentity.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./library/Address.sol\";\nimport \"./library/Signature.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title CXIP Provenance\n * @author CXIP-Labs\n * @notice A smart contract for managing and validating all of CXIP's provenance.\n * @dev For a CXIP Identity to be valid, it needs to be made through CXIP Provenance.\n */\ncontract CxipProvenance {\n    /**\n     * @dev Complete map of all wallets and their associated identities.\n     */\n    mapping(address => address) private _walletToIdentityMap;\n    /**\n     * @dev Used for mapping created identity addresses.\n     */\n    mapping(address => bool) private _identityMap;\n    /**\n     * @dev Special map for storing blacklisted identities.\n     */\n    mapping(address => bool) private _blacklistMap;\n\n    /**\n     * @dev Reentrancy implementation from OpenZepellin. State 1 == NOT_ENDERED, State 2 == ENTERED\n     */\n    uint256 private _reentrancyState;\n\n    /**\n     * @notice Event emitted when an identity gets blacklisted.\n     * @dev This is reserved for later use, in cases where an identity needs to be publicly blacklisted.\n     * @param identityAddress Address of the identity being blacklisted.\n     * @param reason A string URI to Arweave, IPFS, or HTTP with a detailed explanation for the blacklist.\n     */\n    event IdentityBlacklisted(address indexed identityAddress, string reason);\n    /**\n     * @notice Event emitted when a new identity is created.\n     * @dev Can subscribe to this even on Provenance to get all CXIP created identities.\n     * @param identityAddress Address of the identity being created.\n     */\n    event IdentityCreated(address indexed identityAddress);\n    /**\n     * @notice Event emitted when a new wallet is added to the identity.\n     * @dev A wallet can only be added to one identity. It will not be possible to ever use it with another identity after that.\n     * @param identityAddress Address of the identity being created.\n     * @param initiatingWallet The address of wallet that initiated adding the new wallet.\n     * @param newWallet The address of new wallet being added.\n     */\n    event IdentityWalletAdded(\n        address indexed identityAddress,\n        address indexed initiatingWallet,\n        address indexed newWallet\n    );\n\n    /**\n     * @notice Constructor is empty and only reentrancy guard is implemented.\n     * @dev There is no data that needs to be set on first time deployment.\n     */\n    constructor() {\n        _reentrancyState = 1;\n    }\n\n    /**\n     * @dev Implementation from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\n     */\n    modifier nonReentrant() {\n        require(_reentrancyState != 2, \"ReentrancyGuard: reentrant call\");\n        _reentrancyState = 2;\n        _;\n        _reentrancyState = 1;\n    }\n\n    /**\n     * @notice Create a new identity smart contract.\n     * @dev Only a wallet that is not already associated with any CXIP Identity can create a new identity.\n     * @param saltHash A salt made up of 12 bytes random data and 20 bytes msg.sender address.\n     * @param secondaryWallet An additional wallet to add to identity. Used mostly for proxy wallets.\n     * @param verification Signatures made by msg.sender to validate identity creation.\n     */\n    function createIdentity(\n        bytes32 saltHash,\n        address secondaryWallet,\n        Verification calldata verification\n    ) public nonReentrant {\n        bool usingSecondaryWallet = !Address.isZero(secondaryWallet);\n        address wallet = msg.sender;\n        require(\n            !Address.isContract(wallet),\n            \"CXIP: cannot use smart contracts\"\n        );\n        require(\n            Address.isZero(_walletToIdentityMap[wallet]),\n            \"CXIP: wallet already used\"\n        );\n        require(\n            address(\n                uint160(\n                    bytes20(saltHash)\n                )\n            ) == wallet,\n            \"CXIP: invalid salt hash\"\n        );\n        if(usingSecondaryWallet) {\n            require(\n                !Address.isContract(secondaryWallet),\n                \"CXIP: cannot use smart contracts\"\n            );\n            require(\n                Address.isZero(_walletToIdentityMap[secondaryWallet]),\n                \"CXIP: second wallet already used\"\n            );\n            require(\n                Signature.Valid(\n                    secondaryWallet,\n                    verification.r,\n                    verification.s,\n                    verification.v,\n                    abi.encodePacked(\n                        address(this),\n                        wallet,\n                        secondaryWallet\n                    )\n                ),\n                \"CXIP: invalid signature\"\n            );\n        }\n        bytes memory bytecode = hex\"608060405234801561001057600080fd5b50610128806100206000396000f3fe608060408190527f38dc9c6800000000000000000000000000000000000000000000000000000000815260009073deaDDeADDEaDdeaDdEAddEADDEAdDeadDEADDEaD906338dc9c689060849060209060048186803b158015605f57600080fd5b505afa1580156072573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906094919060b9565b90503660008037600080366000845af43d6000803e80801560b4573d6000f35b3d6000fd5b60006020828403121560c9578081fd5b815173ffffffffffffffffffffffffffffffffffffffff8116811460eb578182fd5b939250505056fea2646970667358221220fdc58b44f80b9f0e5d40441fd91201d5e8359fd755ec84feeef0b794c446ba9a64736f6c63430008040033\";\n        address identityAddress;\n        assembly {\n            identityAddress := create2(\n                0,\n                add(bytecode, 0x20),\n                mload(bytecode),\n                saltHash\n            )\n        }\n        ICxipIdentity(identityAddress).init(wallet, secondaryWallet);\n        _walletToIdentityMap[wallet] = identityAddress;\n        _identityMap[identityAddress] = true;\n        _notifyIdentityCreated(identityAddress);\n        _notifyIdentityWalletAdded(identityAddress, wallet, wallet);\n        if(usingSecondaryWallet) {\n            _notifyIdentityWalletAdded(\n                identityAddress,\n                wallet,\n                secondaryWallet\n            );\n        }\n    }\n\n    /**\n     * @notice Tells provenance to emit IdentityWalletAdded event(s).\n     * @dev Can only be called by a valid identity associated wallet.\n     * @param newWallet Address of wallet to emit event for.\n     */\n    function informAboutNewWallet(address newWallet) public nonReentrant {\n        address identityAddress = msg.sender;\n        require(\n            _identityMap[identityAddress],\n            \"CXIP: invalid Identity contract\"\n        );\n        require(\n            Address.isZero(_walletToIdentityMap[newWallet]),\n            \"CXIP: wallet already added\"\n        );\n        ICxipIdentity identity = ICxipIdentity(identityAddress);\n        require(\n            identity.isWalletRegistered(newWallet),\n            \"CXIP: unregistered wallet\"\n        );\n        _notifyIdentityWalletAdded(\n            identityAddress,\n            identity.getAuthorizer(newWallet),\n            newWallet\n        );\n        _walletToIdentityMap[newWallet] = identityAddress;\n    }\n\n    /**\n     * @notice Get the identity of current wallet.\n     * @dev Gets identity of msg.sender.\n     * @return address Returns an identity contract address, or zero address if wallet is not associated with any identity.\n     */\n    function getIdentity() public view returns (address) {\n        return _walletToIdentityMap[msg.sender];\n    }\n\n    /**\n     * @notice Get the identity associated with a wallet.\n     * @dev Can also be used to check if a wallet can create a new identity.\n     * @param wallet Address of wallet to get identity for.\n     * @return address Returns an identity contract address, or zero address if wallet is not associated with any identity.\n     */\n    function getWalletIdentity(address wallet) public view returns (address) {\n        return _walletToIdentityMap[wallet];\n    }\n\n    /**\n     * @notice Check if an identity is blacklisted.\n     * @dev This is an optional function that can be used to decide if an identity should be not interacted with.\n     * @param identityAddress Contract address of the identity\n     * @return bool Returns true if identity was blacklisted.\n     */\n    function isIdentityBlacklisted(\n        address identityAddress\n    ) public view returns (bool) {\n        return _blacklistMap[identityAddress];\n    }\n\n    /**\n     * @notice Check if an identity is valid.\n     * @dev This is used to ensure provenance and prevent malicious actors from creating smart contract clones.\n     * @param identityAddress Contract address of the identity\n     * @return bool Returns true if identity was created through proper provenance.\n     */\n    function isIdentityValid(\n        address identityAddress\n    ) public view returns (bool) {\n        return (\n            _identityMap[identityAddress]\n            && !_blacklistMap[identityAddress]\n        );\n    }\n\n    /**\n     * @dev Trigger the IdentityBlacklisted event.\n     * @param contractAddress Address of identity that is being blacklisted.\n     * @param reason String URI of Arweave, IPFS, or HTTP link explaining reason for blacklisting.\n     */\n    function _notifyIdentityBlacklisted(\n        address contractAddress,\n        string calldata reason\n    ) internal {\n        emit IdentityBlacklisted(contractAddress, reason);\n    }\n\n    /**\n     * @dev Trigger the IdentityCreated event.\n     * @param contractAddress Address of identity that is being created.\n     */\n    function _notifyIdentityCreated(address contractAddress) internal {\n        emit IdentityCreated(contractAddress);\n    }\n\n    /**\n     * @dev Trigger the IdentityWalletAdded event.\n     * @param identityAddress Address of identity that wallet is being added to.\n     * @param intiatingWallet Address of wallet that is triggering this event.\n     * @param newWallet Address of wallet that is being added to this identity.\n     */\n    function _notifyIdentityWalletAdded(\n        address identityAddress,\n        address intiatingWallet,\n        address newWallet\n    ) internal {\n        emit IdentityWalletAdded(identityAddress, intiatingWallet, newWallet);\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n    }\n}\n"
    },
    "contracts/PA1D.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./library/Address.sol\";\nimport \"./library/Zora.sol\";\nimport \"./interface/IERC20.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./interface/ICxipERC.sol\";\nimport \"./interface/ICxipIdentity.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D {\n    /**\n     * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n     * @dev Emits event in order to comply with Rarible V1 royalty spec.\n     * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n     * @param recipients Address array of wallets that will receive tha royalties.\n     * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n     */\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n    /**\n     * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"PA1D: caller not an owner\");\n        _;\n    }\n\n    /**\n     * @notice Constructor is empty and not utilised.\n     * @dev Since the smart contract is being used inside of a fallback context, the constructor function is not being used.\n     */\n    constructor() {}\n\n    /**\n     * @notice Initialise the smart contract on source smart contract deployment/initialisation.\n     * @dev Use the init function once, when deploying or initialising your overlying smart contract.\n     * @dev Take great care to not expose this function to your other public functions.\n     * @param tokenId Specify a particular token id only if using the init function for a special case. Otherwise leave empty(0).\n     * @param receiver The address for the default receiver of all royalty payouts. Recommended to use the overlying smart contract address. This will allow the PA1D smart contract to handle all royalty settings, receipt, and distribution.\n     * @param bp The default base points(percentage) for royalty payouts.\n     */\n    function init(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) public onlyOwner {\n        //         if (Address.isZero(receiver)) {\n        //             receiver = payable(this);\n        //         }\n        //         setRoyalties(tokenId, receiver, bp);\n        //         // We register the smart contract with Rarible(V1) as the controller for royalties.\n        //         // This makes sure that all royalty info will be queried from the contract and not somewhere else\n        //         /**\n        //          * @dev Keep in mind that Rarible V1 makes a \"owner\" function call to the overlying smart contract.\n        //          * @dev It is mandatory to have owner function call return this contract address, or the function will fail.\n        //          */\n        //         (\n        //             bool setProviderSuccess, /*bytes memory setProviderResponse*/\n        //         ) = address(0x20202052617269626C6520526F79616c74696573).call(\n        //                 /**\n        //                  * @dev We hardcode the bytes4 function hash to save on gas\n        //                  */\n        //                 // abi.encodeWithSignature(\n        //                 //     'setProviderByToken(address,address)',\n        //                 abi.encodeWithSelector(bytes4(0xd836f013), address(this), address(this))\n        //             );\n        //         require(setProviderSuccess, \"PA1D: failed setting Rarible\");\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n    }\n\n    /**\n     * @notice Check if the underlying identity has sender as registered wallet.\n     * @dev Check the overlying smart contract's identity for wallet registration.\n     * @param sender Address which should be checked against the identity.\n     * @return Returns true if the sender is a valid wallet of the identity.\n     */\n    function isIdentityWallet(address sender) internal view returns (bool) {\n        return isIdentityWallet(ICxipERC(address(this)).getIdentity(), sender);\n    }\n\n    /**\n     * @notice Check if a specific identity has sender as registered wallet.\n     * @dev Don't use this function directly unless you know what you're doing.\n     * @param identity Address of the identity smart contract.\n     * @param sender Address which should be checked against the identity.\n     * @return Returns true if the sender is a valid wallet of the identity.\n     */\n    function isIdentityWallet(address identity, address sender) internal view returns (bool) {\n        if (Address.isZero(identity)) {\n            return false;\n        }\n        return ICxipIdentity(identity).isWalletRegistered(sender);\n    }\n\n    /**\n     * @notice Check if message sender is a legitimate owner of the smart contract\n     * @dev We check owner, admin, and identity for a more comprehensive coverage.\n     * @return Returns true is message sender is an owner.\n     */\n    function isOwner() internal view returns (bool) {\n        ICxipERC erc = ICxipERC(address(this));\n        return (msg.sender == erc.owner() ||\n            msg.sender == erc.admin() ||\n            isIdentityWallet(erc.getIdentity(), msg.sender));\n    }\n\n    /**\n     * @dev Gets the default royalty payment receiver address from storage slot.\n     * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n     */\n    function _getDefaultReceiver() internal view returns (address payable receiver) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultReceiver')) - 1);\n        assembly {\n            receiver := sload(\n                /* slot */\n                0xaee4e97c19ce50ea5345ba9751676d533a3a7b99c3568901208f92f9eea6a7f2\n            )\n        }\n    }\n\n    /**\n     * @dev Sets the default royalty payment receiver address to storage slot.\n     * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n     */\n    function _setDefaultReceiver(address receiver) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultReceiver')) - 1);\n        assembly {\n            sstore(\n                /* slot */\n                0xaee4e97c19ce50ea5345ba9751676d533a3a7b99c3568901208f92f9eea6a7f2,\n                receiver\n            )\n        }\n    }\n\n    /**\n     * @dev Gets the default royalty base points(percentage) from storage slot.\n     * @return bp Royalty base points(percentage) for royalty payouts.\n     */\n    function _getDefaultBp() internal view returns (uint256 bp) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultBp')) - 1);\n        assembly {\n            bp := sload(\n                /* slot */\n                0xfd198c3b406b2320ea9f4a413c7a69a7592dbfc4175b8c252fec24223e68b720\n            )\n        }\n    }\n\n    /**\n     * @dev Sets the default royalty base points(percentage) to storage slot.\n     * @param bp Uint256 of royalty percentage, provided in base points format.\n     */\n    function _setDefaultBp(uint256 bp) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultBp')) - 1);\n        assembly {\n            sstore(\n                /* slot */\n                0xfd198c3b406b2320ea9f4a413c7a69a7592dbfc4175b8c252fec24223e68b720,\n                bp\n            )\n        }\n    }\n\n    /**\n     * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n     * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n     */\n    function _getReceiver(uint256 tokenId) internal view returns (address payable receiver) {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.receiver\", tokenId))) - 1\n        );\n        assembly {\n            receiver := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n     * @param tokenId Uint256 of the token id to set the receiver for.\n     * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n     */\n    function _setReceiver(uint256 tokenId, address receiver) internal {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.receiver\", tokenId))) - 1\n        );\n        assembly {\n            sstore(slot, receiver)\n        }\n    }\n\n    /**\n     * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n     * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n     */\n    function _getBp(uint256 tokenId) internal view returns (uint256 bp) {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.bp\", tokenId))) - 1\n        );\n        assembly {\n            bp := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n     * @param tokenId Uint256 of the token id to set the base points for.\n     * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n     */\n    function _setBp(uint256 tokenId, uint256 bp) internal {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.bp\", tokenId))) - 1\n        );\n        assembly {\n            sstore(slot, bp)\n        }\n    }\n\n    function _getPayoutAddresses() internal view returns (address payable[] memory addresses) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.addresses')) - 1);\n        assembly {\n            addresses := sload(\n                /* slot */\n                0xda9d0b1bc91e594968e30b896be60318d483303fc3ba08af8ac989d483bdd7ca\n            )\n        }\n    }\n\n    function _setPayoutAddresses(address payable[] memory addresses) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.addresses')) - 1);\n        assembly {\n            sstore(\n                /* slot */\n                0xda9d0b1bc91e594968e30b896be60318d483303fc3ba08af8ac989d483bdd7ca,\n                addresses\n            )\n        }\n    }\n\n    function _getPayoutBps() internal view returns (uint256[] memory bps) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.bps')) - 1);\n        assembly {\n            bps := sload(\n                /* slot */\n                0x7862b872ab9e3483d8176282b22f4ac86ad99c9035b3f794a541d84a66004fa2\n            )\n        }\n    }\n\n    function _setPayoutBps(uint256[] memory bps) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.bps')) - 1);\n        assembly {\n            sstore(\n                /* slot */\n                0x7862b872ab9e3483d8176282b22f4ac86ad99c9035b3f794a541d84a66004fa2,\n                bps\n            )\n        }\n    }\n\n    function _getTokenAddress(string memory tokenName)\n        internal\n        view\n        returns (address tokenAddress)\n    {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.tokenAddress\", tokenName))) - 1\n        );\n        assembly {\n            tokenAddress := sload(slot)\n        }\n    }\n\n    function _setTokenAddress(string memory tokenName, address tokenAddress) internal {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.tokenAddress\", tokenName))) - 1\n        );\n        assembly {\n            sstore(slot, tokenAddress)\n        }\n    }\n\n    /**\n     * @dev Internal function that transfers ETH to all payout recipients.\n     */\n    function _payoutEth() internal {\n        address payable[] memory addresses = _getPayoutAddresses();\n        uint256[] memory bps = _getPayoutBps();\n        uint256 length = addresses.length;\n        // accommodating the 2300 gas stipend\n        // adding 1x for each item in array to accomodate rounding errors\n        uint256 gasCost = (23300 * length) + length;\n        uint256 balance = address(this).balance;\n        require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n        balance = balance - gasCost;\n        uint256 sending;\n        // uint256 sent;\n        for (uint256 i = 0; i < length; i++) {\n            sending = ((bps[i] * balance) / 10000);\n            addresses[i].transfer(sending);\n            // sent = sent + sending;\n        }\n    }\n\n    /**\n     * @dev Internal function that transfers tokens to all payout recipients.\n     * @param tokenAddress Smart contract address of ERC20 token.\n     */\n    function _payoutToken(address tokenAddress) internal {\n        address payable[] memory addresses = _getPayoutAddresses();\n        uint256[] memory bps = _getPayoutBps();\n        uint256 length = addresses.length;\n        IERC20 erc20 = IERC20(tokenAddress);\n        uint256 balance = erc20.balanceOf(address(this));\n        require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n        uint256 sending;\n        //uint256 sent;\n        for (uint256 i = 0; i < length; i++) {\n            sending = ((bps[i] * balance) / 10000);\n            require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n            // sent = sent + sending;\n        }\n    }\n\n    /**\n     * @dev Internal function that transfers multiple tokens to all payout recipients.\n     * @dev Try to use _payoutToken and handle each token individually.\n     * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n     */\n    function _payoutTokens(address[] memory tokenAddresses) internal {\n        address payable[] memory addresses = _getPayoutAddresses();\n        uint256[] memory bps = _getPayoutBps();\n        IERC20 erc20;\n        uint256 balance;\n        uint256 sending;\n        for (uint256 t = 0; t < tokenAddresses.length; t++) {\n            erc20 = IERC20(tokenAddresses[t]);\n            balance = erc20.balanceOf(address(this));\n            require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n            // uint256 sent;\n            for (uint256 i = 0; i < addresses.length; i++) {\n                sending = ((bps[i] * balance) / 10000);\n                require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n                // sent = sent + sending;\n            }\n        }\n    }\n\n    /**\n     * @dev This function validates that the call is being made by an authorised wallet.\n     * @dev Will revert entire tranaction if it fails.\n     */\n    function _validatePayoutRequestor() internal view {\n        if (!isOwner()) {\n            bool matched;\n            address payable[] memory addresses = _getPayoutAddresses();\n            address payable sender = payable(msg.sender);\n            for (uint256 i = 0; i < addresses.length; i++) {\n                if (addresses[i] == sender) {\n                    matched = true;\n                    break;\n                }\n            }\n            require(matched, \"PA1D: sender not authorized\");\n        }\n    }\n\n    /**\n     * @notice Set the wallets and percentages for royalty payouts.\n     * @dev Function can only we called by owner, admin, or identity wallet.\n     * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n     * @param addresses An array of all the addresses that will be receiving royalty payouts.\n     * @param bps An array of the percentages that each address will receive from the royalty payouts.\n     */\n    function configurePayouts(address payable[] memory addresses, uint256[] memory bps)\n        public\n        onlyOwner\n    {\n        require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n        uint256 totalBp;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            totalBp = totalBp + bps[i];\n        }\n        require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n        _setPayoutAddresses(addresses);\n        _setPayoutBps(bps);\n    }\n\n    /**\n     * @notice Show the wallets and percentages of payout recipients.\n     * @dev These are the recipients that will be getting royalty payouts.\n     * @return addresses An array of all the addresses that will be receiving royalty payouts.\n     * @return bps An array of the percentages that each address will receive from the royalty payouts.\n     */\n    function getPayoutInfo()\n        public\n        view\n        returns (address payable[] memory addresses, uint256[] memory bps)\n    {\n        addresses = _getPayoutAddresses();\n        bps = _getPayoutBps();\n    }\n\n    /**\n     * @notice Get payout of all ETH in smart contract.\n     * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n     */\n    function getEthPayout() public {\n        _validatePayoutRequestor();\n        _payoutEth();\n    }\n\n    /**\n     * @notice Get payout for a specific token address. Token must have a positive balance!\n     * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n     * @param tokenAddress An address of the token for which to issue payouts for.\n     */\n    function getTokenPayout(address tokenAddress) public {\n        _validatePayoutRequestor();\n        _payoutToken(tokenAddress);\n    }\n\n    /**\n     * @notice Get payout for a specific token name. Token must have a positive balance!\n     * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n     * @dev Avoid using this function at all costs, due to high gas usage, and no guarantee for token support.\n     * @param tokenName A string of the token name for which to issue payouts for.\n     */\n    function getTokenPayoutByName(string memory tokenName) public {\n        _validatePayoutRequestor();\n        address tokenAddress = PA1D(payable(getRegistry().getPA1D())).getTokenAddress(tokenName);\n        require(!Address.isZero(tokenAddress), \"PA1D: Token address not found\");\n        _payoutToken(tokenAddress);\n    }\n\n    /**\n     * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n     * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n     * @param tokenAddresses An address array of tokens to issue payouts for.\n     */\n    function getTokensPayout(address[] memory tokenAddresses) public {\n        _validatePayoutRequestor();\n        _payoutTokens(tokenAddresses);\n    }\n\n    /**\n     * @notice Get payouts for tokens listed by name. Tokens must have a positive balance!\n     * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n     * @dev Avoid using this function at all costs, due to high gas usage, and no guarantee for token support.\n     * @param tokenNames A string array of token names to issue payouts for.\n     */\n    function getTokensPayoutByName(string[] memory tokenNames) public {\n        _validatePayoutRequestor();\n        uint256 length = tokenNames.length;\n        address[] memory tokenAddresses = new address[](length);\n        for (uint256 i = 0; i < length; i++) {\n            address tokenAddress = PA1D(payable(getRegistry().getPA1D())).getTokenAddress(\n                tokenNames[i]\n            );\n            require(!Address.isZero(tokenAddress), \"PA1D: Token address not found\");\n            tokenAddresses[i] = tokenAddress;\n        }\n        _payoutTokens(tokenAddresses);\n    }\n\n    /**\n     * @notice Inform about supported interfaces(eip-165).\n     * @dev Provides the supported interface ids that this contract implements.\n     * @param interfaceId Bytes4 of the interface, derived through bytes4(keccak256('sampleFunction(uin256,address)')).\n     * @return True if function is supported/implemented, false if not.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        if (\n            // EIP2981\n            // bytes4(keccak256('royaltyInfo(uint256,uint256)')) == 0x2a55205a\n            interfaceId == 0x2a55205a ||\n            // Rarible V1\n            // bytes4(keccak256('getFeeBps(uint256)')) == 0xb7799584\n            interfaceId == 0xb7799584 ||\n            // Rarible V1\n            // bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n            interfaceId == 0xb9c4d9fb ||\n            // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n            // bytes4(keccak256('getRoyalties(uint256)')) == 0xcad96cca\n            // interfaceId == 0xcad96cca ||\n            // Manifold\n            // bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n            interfaceId == 0xbb3bafd6 ||\n            // Foundation\n            // bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\n            interfaceId == 0xd5a06d4c ||\n            // SuperRare\n            // bytes4(keccak256('tokenCreator(address,uint256)')) == 0xb85ed7e4\n            interfaceId == 0xb85ed7e4 ||\n            // SuperRare\n            // bytes4(keccak256('calculateRoyaltyFee(address,uint256,uint256)')) == 0x860110f5\n            interfaceId == 0x860110f5 ||\n            // Zora\n            // bytes4(keccak256('marketContract()')) == 0xa1794bcd\n            interfaceId == 0xa1794bcd ||\n            // Zora\n            // bytes4(keccak256('tokenCreators(uint256)')) == 0xe0fd045f\n            interfaceId == 0xe0fd045f ||\n            // Zora\n            // bytes4(keccak256('bidSharesForToken(uint256)')) == 0xf9ce0582\n            interfaceId == 0xf9ce0582\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Set the royalty information for entire contract, or a specific token.\n     * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n     * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n     * @param receiver Wallet or smart contract that will receive the royalty payouts.\n     * @param bp Uint256 of royalty percentage, provided in base points format.\n     */\n    function setRoyalties(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) public onlyOwner {\n        if (tokenId == 0) {\n            _setDefaultReceiver(receiver);\n            _setDefaultBp(bp);\n        } else {\n            _setReceiver(tokenId, receiver);\n            _setBp(tokenId, bp);\n        }\n        address[] memory receivers = new address[](1);\n        receivers[0] = address(receiver);\n        uint256[] memory bps = new uint256[](1);\n        bps[0] = bp;\n        emit SecondarySaleFees(tokenId, receivers, bps);\n    }\n\n    // IEIP2981\n    function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n        if (_getReceiver(tokenId) == address(0)) {\n            return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n        } else {\n            return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n        }\n    }\n\n    // Rarible V1\n    function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n        uint256[] memory bps = new uint256[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            bps[0] = _getDefaultBp();\n        } else {\n            bps[0] = _getBp(tokenId);\n        }\n        return bps;\n    }\n\n    // Rarible V1\n    function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n        address payable[] memory receivers = new address payable[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            receivers[0] = _getDefaultReceiver();\n        } else {\n            receivers[0] = _getReceiver(tokenId);\n        }\n        return receivers;\n    }\n\n    // Rarible V2(not being used since it creates a conflict with Manifold royalties)\n    // struct Part {\n    //     address payable account;\n    //     uint96 value;\n    // }\n\n    // function getRoyalties(uint256 tokenId) public view returns (Part[] memory) {\n    //     return royalties[id];\n    // }\n\n    // Manifold\n    function getRoyalties(uint256 tokenId)\n        public\n        view\n        returns (address payable[] memory, uint256[] memory)\n    {\n        address payable[] memory receivers = new address payable[](1);\n        uint256[] memory bps = new uint256[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            receivers[0] = _getDefaultReceiver();\n            bps[0] = _getDefaultBp();\n        } else {\n            receivers[0] = _getReceiver(tokenId);\n            bps[0] = _getBp(tokenId);\n        }\n        return (receivers, bps);\n    }\n\n    // Foundation\n    function getFees(uint256 tokenId)\n        public\n        view\n        returns (address payable[] memory, uint256[] memory)\n    {\n        address payable[] memory receivers = new address payable[](1);\n        uint256[] memory bps = new uint256[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            receivers[0] = _getDefaultReceiver();\n            bps[0] = _getDefaultBp();\n        } else {\n            receivers[0] = _getReceiver(tokenId);\n            bps[0] = _getBp(tokenId);\n        }\n        return (receivers, bps);\n    }\n\n    // SuperRare\n    // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n    // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n    // We'll just leave this here for just in case they open the flood gates.\n    function tokenCreator(\n        address, /* contractAddress*/\n        uint256 tokenId\n    ) public view returns (address) {\n        address receiver = _getReceiver(tokenId);\n        if (receiver == address(0)) {\n            return _getDefaultReceiver();\n        }\n        return receiver;\n    }\n\n    // SuperRare\n    function calculateRoyaltyFee(\n        address, /* contractAddress */\n        uint256 tokenId,\n        uint256 amount\n    ) public view returns (uint256) {\n        if (_getReceiver(tokenId) == address(0)) {\n            return (_getDefaultBp() * amount) / 10000;\n        } else {\n            return (_getBp(tokenId) * amount) / 10000;\n        }\n    }\n\n    // Zora\n    // we indicate that this contract operates market functions\n    function marketContract() public view returns (address) {\n        return address(this);\n    }\n\n    // Zora\n    // we indicate that the receiver is the creator, to convince the smart contract to pay\n    function tokenCreators(uint256 tokenId) public view returns (address) {\n        address receiver = _getReceiver(tokenId);\n        if (receiver == address(0)) {\n            return _getDefaultReceiver();\n        }\n        return receiver;\n    }\n\n    // Zora\n    // we provide the percentage that needs to be paid out from the sale\n    function bidSharesForToken(uint256 tokenId)\n        public\n        view\n        returns (Zora.BidShares memory bidShares)\n    {\n        // this information is outside of the scope of our\n        bidShares.prevOwner.value = 0;\n        bidShares.owner.value = 0;\n        if (_getReceiver(tokenId) == address(0)) {\n            bidShares.creator.value = _getDefaultBp();\n        } else {\n            bidShares.creator.value = _getBp(tokenId);\n        }\n        return bidShares;\n    }\n\n    /**\n     * @notice Get the storage slot for given string\n     * @dev Convert a string to a bytes32 storage slot\n     * @param slot The string name of storage slot(without the 'eip1967.PA1D.' prefix)\n     * @return A bytes32 reference to the storage slot\n     */\n    function getStorageSlot(string calldata slot) public pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.\", slot))) - 1);\n    }\n\n    /**\n     * @notice Get the smart contract address of a token by common name.\n     * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n     * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n     * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n     */\n    function getTokenAddress(string memory tokenName) public view returns (address) {\n        return _getTokenAddress(tokenName);\n    }\n\n    /**\n     * @notice Forwards unknown function call to the CXIP hotfixes smart contract(if present)\n     * @dev All unrecognized functions are delegated to hotfixes smart contract which can be utilized to deploy on-chain hotfixes\n     */\n    function _defaultFallback() internal {\n        /**\n         * @dev Very important to note the use of sha256 instead of keccak256 in this function. Since the registry is made to be front-facing and user friendly, the choice to use sha256 was made due to the accessibility of that function in comparison to keccak.\n         */\n        address _target = getRegistry().getCustomSource(\n            sha256(abi.encodePacked(\"eip1967.CXIP.hotfixes\"))\n        );\n\n        /**\n         * @dev To minimize gas usage, pre-calculate the 32 byte hash and provide the final hex string instead of running the sha256 function on each call inside the smart contract\n         */\n        // address _target = getRegistry().getCustomSource(0x45f5c3bc3dbabbfab15d44af18b96716cf5bec748c58d54d61c4e7293de6763e);\n        /**\n         * @dev Assembly is used to minimize gas usage and pass the data directly through\n         */\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Forwarding all unknown functions to default fallback\n     */\n    fallback() external {\n        _defaultFallback();\n    }\n\n    /**\n     * @dev This is intentionally left empty, to make sure that ETH transfers succeed.\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/library/Zora.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Zora {\n    struct Decimal {\n        uint256 value;\n    }\n\n    struct BidShares {\n        // % of sale value that goes to the _previous_ owner of the nft\n        Decimal prevOwner;\n        // % of sale value that goes to the original creator of the nft\n        Decimal creator;\n        // % of sale value that goes to the seller (current owner) of the nft\n        Decimal owner;\n    }\n}\n"
    },
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interface/ICxipERC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface ICxipERC {\n    function admin() external view returns (address);\n\n    function getIdentity() external view returns (address);\n\n    function isAdmin() external view returns (bool);\n\n    function isOwner() external view returns (bool);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/CxipERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./external/OpenSea.sol\";\nimport \"./interface/ICxipERC721.sol\";\nimport \"./interface/ICxipIdentity.sol\";\nimport \"./interface/ICxipProvenance.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./interface/IPA1D.sol\";\nimport \"./library/Address.sol\";\nimport \"./library/Bytes.sol\";\nimport \"./library/Strings.sol\";\nimport \"./struct/CollectionData.sol\";\nimport \"./struct/TokenData.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title CXIP ERC721\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract CxipERC721 {\n    /**\n     * @dev Stores default collection data: name, symbol, and royalties.\n     */\n    CollectionData private _collectionData;\n\n    /**\n     * @dev Internal last minted token id, to allow for auto-increment.\n     */\n    uint256 private _currentTokenId;\n\n    /**\n     * @dev Array of all token ids in collection.\n     */\n    uint256[] private _allTokens;\n\n    /**\n     * @dev Map of token id to array index of _ownedTokens.\n     */\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    /**\n     * @dev Token id to wallet (owner) address map.\n     */\n    mapping(uint256 => address) private _tokenOwner;\n\n    /**\n     * @dev 1-to-1 map of token id that was assigned an approved operator address.\n     */\n    mapping(uint256 => address) private _tokenApprovals;\n\n    /**\n     * @dev Map of total tokens owner by a specific address.\n     */\n    mapping(address => uint256) private _ownedTokensCount;\n\n    /**\n     * @dev Map of array of token ids owned by a specific address.\n     */\n    mapping(address => uint256[]) private _ownedTokens;\n\n    /**\n     * @notice Map of full operator approval for a particular address.\n     * @dev Usually utilised for supporting marketplace proxy wallets.\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Token data mapped by token id.\n     */\n    mapping(uint256 => TokenData) private _tokenData;\n\n    /**\n     * @dev Address of admin user. Primarily used as an additional recover address.\n     */\n    address private _admin;\n\n    /**\n     * @dev Address of contract owner. This address can run all onlyOwner functions.\n     */\n    address private _owner;\n\n    /**\n     * @dev Simple tracker of all minted (not-burned) tokens.\n     */\n    uint256 private _totalTokens;\n\n    /**\n     * @notice Event emitted when an token is minted, transfered, or burned.\n     * @dev If from is empty, it's a mint. If to is empty, it's a burn. Otherwise, it's a transfer.\n     * @param from Address from where token is being transfered.\n     * @param to Address to where token is being transfered.\n     * @param tokenId Token id that is being minted, Transfered, or burned.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @notice Event emitted when an address delegates power, for a token, to another address.\n     * @dev Emits event that informs of address approving a third-party operator for a particular token.\n     * @param wallet Address of the wallet configuring a token operator.\n     * @param operator Address of the third-party operator approved for interaction.\n     * @param tokenId A specific token id that is being authorised to operator.\n     */\n    event Approval(address indexed wallet, address indexed operator, uint256 indexed tokenId);\n\n    /**\n     * @notice Event emitted when an address authorises an operator (third-party).\n     * @dev Emits event that informs of address approving/denying a third-party operator.\n     * @param wallet Address of the wallet configuring it's operator.\n     * @param operator Address of the third-party operator that interacts on behalf of the wallet.\n     * @param approved A boolean indicating whether approval was granted or revoked.\n     */\n    event ApprovalForAll(address indexed wallet, address indexed operator, bool approved);\n\n    /**\n     * @notice Event emitted to signal to OpenSea that a permanent URI was created.\n     * @dev Even though OpenSea advertises support for this, they do not listen to this event, and do not respond to it.\n     * @param uri The permanent/static URL of the NFT. Cannot ever be changed again.\n     * @param id Token id of the NFT.\n     */\n    event PermanentURI(string uri, uint256 indexed id);\n\n    /**\n     * @notice Constructor is empty and not utilised.\n     * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n     */\n    constructor() {}\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"CXIP: caller not an owner\");\n        _;\n    }\n\n    /**\n     * @notice Enables royaltiy functionality at the ERC721 level when ether is sent with no calldata.\n     * @dev See implementation of _royaltiesFallback.\n     */\n    receive() external payable {\n        _royaltiesFallback();\n    }\n\n    /**\n     * @notice Enables royaltiy functionality at the ERC721 level no other function matches the call.\n     * @dev See implementation of _royaltiesFallback.\n     */\n    fallback() external {\n        _royaltiesFallback();\n    }\n\n    /**\n     * @notice Gets the URI of the NFT on Arweave.\n     * @dev Concatenates 2 sections of the arweave URI.\n     * @param tokenId Id of the token.\n     * @return string The URI.\n     */\n    function arweaveURI(uint256 tokenId) external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"https://arweave.cxip.dev/\",\n                    _tokenData[tokenId].arweave,\n                    _tokenData[tokenId].arweave2\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the URI of the NFT backup from CXIP.\n     * @dev Concatenates to https://nft.cxip.dev/.\n     * @return string The URI.\n     */\n    function contractURI() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\"https://nft.cxip.dev/\", Strings.toHexString(address(this)), \"/\")\n            );\n    }\n\n    /**\n     * @notice Gets the creator's address.\n     * @dev If the token Id doesn't exist it will return zero address.\n     * @param tokenId Id of the token.\n     * @return address Creator's address.\n     */\n    function creator(uint256 tokenId) external view returns (address) {\n        return _tokenData[tokenId].creator;\n    }\n\n    /**\n     * @notice Gets the HTTP URI of the token.\n     * @dev Concatenates to the baseURI.\n     * @return string The URI.\n     */\n    function httpURI(uint256 tokenId) external view returns (string memory) {\n        return string(abi.encodePacked(baseURI(), \"/\", Strings.toHexString(tokenId)));\n    }\n\n    /**\n     * @notice Gets the IPFS URI\n     * @dev Concatenates to the IPFS domain.\n     * @param tokenId Id of the token.\n     * @return string The URI.\n     */\n    function ipfsURI(uint256 tokenId) external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"https://ipfs.cxip.dev/\",\n                    _tokenData[tokenId].ipfs,\n                    _tokenData[tokenId].ipfs2\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the name of the collection.\n     * @dev Uses two names to extend the max length of the collection name in bytes\n     * @return string The collection name.\n     */\n    function name() external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    Bytes.trim(_collectionData.name),\n                    Bytes.trim(_collectionData.name2)\n                )\n            );\n    }\n\n    /**\n     * @notice Gets the hash of the NFT data used to create it.\n     * @dev Payload is used for verification.\n     * @param tokenId The Id of the token.\n     * @return bytes32 The hash.\n     */\n    function payloadHash(uint256 tokenId) external view returns (bytes32) {\n        return _tokenData[tokenId].payloadHash;\n    }\n\n    /**\n     * @notice Gets the signature of the signed NFT data used to create it.\n     * @dev Used for signature verification.\n     * @param tokenId The Id of the token.\n     * @return Verification a struct containing v, r, s values of the signature.\n     */\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory) {\n        return _tokenData[tokenId].payloadSignature;\n    }\n\n    /**\n     * @notice Gets the address of the creator.\n     * @dev The creator signs a payload while creating the NFT.\n     * @param tokenId The Id of the token.\n     * @return address The creator.\n     */\n    function payloadSigner(uint256 tokenId) external view returns (address) {\n        return _tokenData[tokenId].creator;\n    }\n\n    /**\n     * @notice Shows the interfaces the contracts support\n     * @dev Must add new 4 byte interface Ids here to acknowledge support\n     * @param interfaceId ERC165 style 4 byte interfaceId.\n     * @return bool True if supported.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        if (\n            interfaceId == 0x01ffc9a7 || // ERC165\n            interfaceId == 0x80ac58cd || // ERC721\n            // || interfaceId == 0x780e9d63 // ERC721Enumerable\n            interfaceId == 0x5b5e139f || // ERC721Metadata\n            interfaceId == 0x150b7a02 || // ERC721TokenReceiver\n            interfaceId == 0xe8a3d485 || // contractURI()\n            IPA1D(getRegistry().getPA1D()).supportsInterface(interfaceId)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Gets the collection's symbol.\n     * @dev Trims the symbol.\n     * @return string The symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return string(Bytes.trim(_collectionData.symbol));\n    }\n\n    /**\n     * @notice Get's the URI of the token.\n     * @dev Defaults the the Arweave URI\n     * @param tokenId The Id of the token.\n     * @return string The URI.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        return\n            string(\n                abi.encodePacked(\n                    \"https://arweave.cxip.dev/\",\n                    _tokenData[tokenId].arweave,\n                    _tokenData[tokenId].arweave2\n                )\n            );\n    }\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @notice Get list of tokens owned by wallet.\n     * @param wallet The wallet address to get tokens for.\n     * @return uint256[] Returns an array of token ids owned by wallet.\n    function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\n        return _ownedTokens[wallet];\n    }\n    */\n\n    /**\n     * @notice Checks if a given hash matches a payload hash.\n     * @dev Uses sha256 instead of keccak.\n     * @param hash The hash to check.\n     * @param payload The payload prehashed.\n     * @return bool True if the hashes match.\n     */\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool) {\n        bytes32 thePayloadHash = sha256(payload);\n        return hash == thePayloadHash;\n    }\n\n    /**\n     * @notice Adds a new address to the token's approval list.\n     * @dev Requires the sender to be in the approved addresses.\n     * @param to The address to approve.\n     * @param tokenId The affected token.\n     */\n    function approve(address to, uint256 tokenId) public {\n        address tokenOwner = _tokenOwner[tokenId];\n        if (to != tokenOwner && _isApproved(msg.sender, tokenId)) {\n            _tokenApprovals[tokenId] = to;\n            emit Approval(tokenOwner, to, tokenId);\n        }\n    }\n\n    /**\n     * @notice Burns the token.\n     * @dev The sender must be the owner or approved.\n     * @param tokenId The token to burn.\n     */\n    function burn(uint256 tokenId) public {\n        if (_isApproved(msg.sender, tokenId)) {\n            address wallet = _tokenOwner[tokenId];\n            require(!Address.isZero(wallet));\n            _clearApproval(tokenId);\n            _tokenOwner[tokenId] = address(0);\n            emit Transfer(wallet, address(0), tokenId);\n            // _removeTokenFromOwnerEnumeration(wallet, tokenId);\n            // uint256 index = _allTokens.length;\n            // index--;\n            // if (index == 0) {\n            //     delete _allTokens;\n            // } else {\n            //     delete _allTokens[index];\n            // }\n            _totalTokens -= 1;\n            delete _tokenData[tokenId];\n        }\n    }\n\n    /**\n     * @notice Initializes the collection.\n     * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n     * @param newOwner The owner of the collection.\n     * @param collectionData The collection data.\n     */\n    function init(address newOwner, CollectionData calldata collectionData) public {\n        require(Address.isZero(_admin), \"CXIP: already initialized\");\n        _admin = msg.sender;\n        // temporary set to self, to pass rarible royalties logic trap\n        _owner = address(this);\n        _collectionData = collectionData;\n        IPA1D(address(this)).init(0, payable(collectionData.royalties), collectionData.bps);\n        // set to actual owner\n        _owner = newOwner;\n    }\n\n    /** Disabled since this flow has not been agreed on.\n     * @notice Transfer received NFTs to contract owner.\n     * @dev Automatically transfer NFTs out of this smart contract to contract owner. This uses gas from sender.\n     * @param _operator The smart contract where NFT is minted/operated.\n     * @param _from The address from where NFT is being transfered from.\n     * @param _tokenId NFT token id.\n     * @param _data Arbitrary data that could be used for special function calls.\n     * @return bytes4 Returns the onERC721Received interfaceId, to confirm successful receipt of NFT transfer.\n     *\n    function onERC721Received(\n        address _operator,\n        address /*_from*\\/,\n        uint256 _tokenId,\n        bytes calldata _data\n    ) public returns (bytes4) {\n        ICxipERC721(_operator).safeTransferFrom(\n            payable(address(this)),\n            _owner,\n            _tokenId,\n            _data\n        );\n        return 0x150b7a02;\n    }\n    */\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     * @param from cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must exist and be owned by `from`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     * @param from cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must exist and be owned by `from`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory /*_data*/\n    ) public payable {\n        if (_isApproved(msg.sender, tokenId)) {\n            _transferFrom(from, to, tokenId);\n        }\n    }\n\n    /**\n     * @notice Adds a new approved operator.\n     * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\n     * @param to The address to approve.\n     * @param approved Turn on or off approval status.\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        if (to != msg.sender) {\n            _operatorApprovals[msg.sender][to] = approved;\n            emit ApprovalForAll(msg.sender, to, approved);\n        } else {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * @param from  cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must be owned by `from`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        transferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n     * @param from  cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must be owned by `from`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory /*_data*/\n    ) public payable {\n        if (_isApproved(msg.sender, tokenId)) {\n            _transferFrom(from, to, tokenId);\n        }\n    }\n\n    /**\n     * @notice Mints and NFT.\n     * @dev Includes event with the Arwave token URI.\n     * @param id The new tokenId.\n     * @param tokenData The token data for the NFT.\n     * @return uint256 The new tokenId.\n     */\n    function cxipMint(uint256 id, TokenData calldata tokenData) public onlyOwner returns (uint256) {\n        if (id == 0) {\n            _currentTokenId += 1;\n            id = _currentTokenId;\n        }\n        _mint(tokenData.creator, id);\n        _tokenData[id] = tokenData;\n        emit PermanentURI(\n            string(abi.encodePacked(\"https://arweave.cxip.dev/\", tokenData.arweave, tokenData.arweave2)),\n            id\n        );\n        return id;\n    }\n\n    /**\n     * @notice Sets a name for the collection.\n     * @dev The name is split in two for gas optimization.\n     * @param newName First part of name.\n     * @param newName2 Second part of name.\n     */\n    function setName(bytes32 newName, bytes32 newName2) public onlyOwner {\n        _collectionData.name = newName;\n        _collectionData.name2 = newName2;\n    }\n\n    /**\n     * @notice Set a symbol for the collection.\n     * @dev This is the ticker symbol for smart contract that shows up on EtherScan.\n     * @param newSymbol The ticker symbol to set for smart contract.\n     */\n    function setSymbol(bytes32 newSymbol) public onlyOwner {\n        _collectionData.symbol = newSymbol;\n    }\n\n    /**\n     * @notice Transfers ownership of the collection.\n     * @dev Can't be the zero address.\n     * @param newOwner Address of new owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        if (!Address.isZero(newOwner)) {\n            _owner = newOwner;\n        }\n    }\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @notice Get total number of tokens owned by wallet.\n     * @dev Used to see total amount of tokens owned by a specific wallet.\n     * @param wallet Address for which to get token balance.\n     * @return uint256 Returns an integer, representing total amount of tokens held by address.\n     *\n    function balanceOf(address wallet) public view returns (uint256) {\n        return _ownedTokensCount[wallet];\n    }\n    */\n\n    /**\n     * @notice Get a base URI for the token.\n     * @dev Concatenates with the CXIP domain name.\n     * @return string the token URI.\n     */\n    function baseURI() public view returns (string memory) {\n        return string(abi.encodePacked(\"https://cxip.dev/nft/\", Strings.toHexString(address(this))));\n    }\n\n    /**\n     * @notice Gets the approved address for the token.\n     * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\n     * @param tokenId Token id to get approved operator for.\n     * @return address Approved address for token.\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @notice Get the associated identity for the collection.\n     * @dev Goes up the chain to read from the registry.\n     * @return address Identity contract address.\n     */\n    function getIdentity() public view returns (address) {\n        return ICxipProvenance(getRegistry().getProvenance()).getWalletIdentity(_owner);\n    }\n\n    /**\n     * @notice Checks if the address is approved.\n     * @dev Includes references to OpenSea and Rarible marketplace proxies.\n     * @param wallet Address of the wallet.\n     * @param operator Address of the marketplace operator.\n     * @return bool True if approved.\n     */\n    function isApprovedForAll(address wallet, address operator) public view returns (bool) {\n        return (_operatorApprovals[wallet][operator] ||\n            // Rarible Transfer Proxy\n            0x72617269626C655472616E7366657250726F7879 == operator ||\n            // OpenSea Transfer Proxy\n            address(\n                OpenSeaProxyRegistry(0x6f70656E5365615472616E7366657250726F7879).proxies(wallet)\n            ) ==\n            operator);\n    }\n\n    /**\n     * @notice Check if the sender is the owner.\n     * @dev The owner could also be the admin or identity contract of the owner.\n     * @return bool True if owner.\n     */\n    function isOwner() public view returns (bool) {\n        return (msg.sender == _owner || msg.sender == _admin || isIdentityWallet(msg.sender));\n    }\n\n    /**\n     * @notice Gets the owner's address.\n     * @dev _owner is first set in init.\n     * @return address Of ower.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Checks who the owner of a token is.\n     * @dev The token must exist.\n     * @param tokenId The token to look up.\n     * @return address Owner of the token.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address tokenOwner = _tokenOwner[tokenId];\n        require(!Address.isZero(tokenOwner), \"ERC721: token does not exist\");\n        return tokenOwner;\n    }\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @notice Get token by index instead of token id.\n     * @dev Helpful for token enumeration where token id info is not yet available.\n     * @param index Index of token in array.\n     * @return uint256 Returns the token id of token located at that index.\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n    */\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @notice Get token from wallet by index instead of token id.\n     * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\n     * @param wallet Specific address for which to get token for.\n     * @param index Index of token in array.\n     * @return uint256 Returns the token id of token located at that index in specified wallet.\n     *\n    function tokenOfOwnerByIndex(\n        address wallet,\n        uint256 index\n    ) public view returns (uint256) {\n        require(index < balanceOf(wallet));\n        return _ownedTokens[wallet][index];\n    }\n    */\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @notice Total amount of tokens in the collection.\n     * @dev Ignores burned tokens.\n     * @return uint256 Returns the total number of active (not burned) tokens.\n     *\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n    */\n\n    /**\n     * @notice Total amount of tokens in the collection.\n     * @dev Ignores burned tokens.\n     * @return uint256 Returns the total number of active (not burned) tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalTokens;\n    }\n\n    /**\n     * @notice Empty function that is triggered by external contract on NFT transfer.\n     * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\n     * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\n     * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\n     * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n     * @return bytes4 Returns the interfaceId of onERC721Received.\n     */\n    function onERC721Received(\n        address, /*_operator*/\n        address, /*_from*/\n        uint256, /*_tokenId*/\n        bytes calldata /*_data*/\n    ) public pure returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    /**\n     * @notice Allows retrieval of royalties from the contract.\n     * @dev This is a default fallback to ensure the royalties are available.\n     */\n    function _royaltiesFallback() internal {\n        address _target = getRegistry().getPA1D();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if an address is an identity contract.\n     * @dev It must also be registred.\n     * @param sender Address to check if registered to identity.\n     * @return bool True if registred identity.\n     */\n    function isIdentityWallet(address sender) internal view returns (bool) {\n        address identity = getIdentity();\n        if (Address.isZero(identity)) {\n            return false;\n        }\n        return ICxipIdentity(identity).isWalletRegistered(sender);\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512);\n    }\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @dev Add a newly minted token into managed list of tokens.\n     * @param to Address of token owner for which to add the token.\n     * @param tokenId Id of token to add.\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\n        _ownedTokensCount[to]++;\n        _ownedTokens[to].push(tokenId);\n    }\n    */\n\n    /**\n     * @notice Deletes a token from the approval list.\n     * @dev Removes from count.\n     * @param tokenId T.\n     */\n    function _clearApproval(uint256 tokenId) private {\n        delete _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @notice Mints an NFT.\n     * @dev Can to mint the token to the zero address and the token cannot already exist.\n     * @param to Address to mint to.\n     * @param tokenId The new token.\n     */\n    function _mint(address to, uint256 tokenId) private {\n        if (Address.isZero(to) || _exists(tokenId)) {\n            assert(false);\n        }\n        _tokenOwner[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        // _addTokenToOwnerEnumeration(to, tokenId);\n        _totalTokens += 1;\n        // _allTokens.push(tokenId);\n    }\n\n    /** Disabled due to tokenEnumeration not enabled.\n     * @dev Remove a token from managed list of tokens.\n     * @param from Address of token owner for which to remove the token.\n     * @param tokenId Id of token to remove.\n    function _removeTokenFromOwnerEnumeration(\n        address from,\n        uint256 tokenId\n    ) private {\n        _ownedTokensCount[from]--;\n        uint256 lastTokenIndex = _ownedTokensCount[from];\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n        if(tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n        if(lastTokenIndex == 0) {\n            delete _ownedTokens[from];\n        } else {\n            delete _ownedTokens[from][lastTokenIndex];\n        }\n    }\n    */\n\n    /**\n     * @dev Primary internal function that handles the transfer/mint/burn functionality.\n     * @param from Address from where token is being transferred. Zero address means it is being minted.\n     * @param to Address to whom the token is being transferred. Zero address means it is being burned.\n     * @param tokenId Id of token that is being transferred/minted/burned.\n     */\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        if (_tokenOwner[tokenId] == from && !Address.isZero(to)) {\n            _clearApproval(tokenId);\n            _tokenOwner[tokenId] = to;\n            emit Transfer(from, to, tokenId);\n            // _removeTokenFromOwnerEnumeration(from, tokenId);\n            // _addTokenToOwnerEnumeration(to, tokenId);\n        } else {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Checks if the token owner exists.\n     * @dev If the address is the zero address no owner exists.\n     * @param tokenId The affected token.\n     * @return bool True if it exists.\n     */\n    function _exists(uint256 tokenId) private view returns (bool) {\n        address tokenOwner = _tokenOwner[tokenId];\n        return !Address.isZero(tokenOwner);\n    }\n\n    /**\n     * @notice Checks if the address is an approved one.\n     * @dev Uses inlined checks for different usecases of approval.\n     * @param spender Address of the spender.\n     * @param tokenId The affected token.\n     * @return bool True if approved.\n     */\n    function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\n        require(_exists(tokenId));\n        address tokenOwner = _tokenOwner[tokenId];\n        return (spender == tokenOwner ||\n            getApproved(tokenId) == spender ||\n            isApprovedForAll(tokenOwner, spender));\n    }\n}\n"
    },
    "contracts/external/OpenSea.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ncontract OpenSeaOwnableDelegateProxy {}\n\ncontract OpenSeaProxyRegistry {\n    mapping(address => OpenSeaOwnableDelegateProxy) public proxies;\n}\n"
    },
    "contracts/interface/IPA1D.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../library/Zora.sol\";\n\ninterface IPA1D {\n    function init(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) external;\n\n    function configurePayouts(address payable[] memory addresses, uint256[] memory bps) external;\n\n    function getPayoutInfo()\n        external\n        view\n        returns (address payable[] memory addresses, uint256[] memory bps);\n\n    function getEthPayout() external;\n\n    function getTokenPayout(address tokenAddress) external;\n\n    function getTokenPayoutByName(string memory tokenName) external;\n\n    function getTokensPayout(address[] memory tokenAddresses) external;\n\n    function getTokensPayoutByName(string[] memory tokenNames) external;\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n\n    function setRoyalties(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) external;\n\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n    function getFeeBps(uint256 tokenId) external view returns (uint256[] memory);\n\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n\n    function getRoyalties(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n\n    function getFees(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n\n    function tokenCreator(address contractAddress, uint256 tokenId) external view returns (address);\n\n    function calculateRoyaltyFee(\n        address contractAddress,\n        uint256 tokenId,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function marketContract() external view returns (address);\n\n    function tokenCreators(uint256 tokenId) external view returns (address);\n\n    function bidSharesForToken(uint256 tokenId)\n        external\n        view\n        returns (Zora.BidShares memory bidShares);\n\n    function getStorageSlot(string calldata slot) external pure returns (bytes32);\n\n    function getTokenAddress(string memory tokenName) external view returns (address);\n}\n"
    },
    "contracts/library/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Bytes {\n    function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\n        uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\n        return (flag == 1 ? true : false);\n    }\n\n    function setBoolean(\n        uint192 _packedBools,\n        uint192 _boolNumber,\n        bool _value\n    ) internal pure returns (uint192) {\n        if (_value) {\n            return _packedBools | (uint192(1) << _boolNumber);\n        } else {\n            return _packedBools & ~(uint192(1) << _boolNumber);\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n        bytes memory tempBytes;\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                tempBytes := mload(0x40)\n                let lengthmod := and(_length, 31)\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n                for {\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n                mstore(tempBytes, _length)\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n        return tempBytes;\n    }\n\n    function trim(bytes32 source) internal pure returns (bytes memory) {\n        uint256 temp = uint256(source);\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return slice(abi.encodePacked(source), 32 - length, length);\n    }\n}\n"
    },
    "contracts/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Strings {\n    function toHexString(address account) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(account)));\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = bytes16(\"0123456789abcdef\")[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/proxy/PA1DProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract PA1DProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512).getPA1DSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipProvenanceProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipProvenanceProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)\n            .getProvenanceSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipIdentityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipIdentityProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)\n            .getIdentitySource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipERC721Proxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)\n            .getERC721CollectionSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipERC1155Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipERC1155Proxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)\n            .getERC1155CollectionSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipCopyrightProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipCopyrightProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)\n            .getCopyrightSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipAssetProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipAssetProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512)\n            .getAssetSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}