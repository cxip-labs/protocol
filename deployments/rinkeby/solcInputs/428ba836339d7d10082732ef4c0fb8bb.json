{
  "language": "Solidity",
  "sources": {
    "contracts/CxipERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./external/OpenSea.sol\";\nimport \"./interface/IERC165.sol\";\nimport \"./interface/ICxipERC721.sol\";\nimport \"./interface/ICxipProvenance.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./interface/IPA1D.sol\";\nimport \"./library/Address.sol\";\nimport \"./library/Bytes.sol\";\nimport \"./library/Strings.sol\";\nimport \"./struct/CollectionData.sol\";\nimport \"./struct/TokenData.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title CXIP ERC721\n * @author CXIP-Labs\n * @notice A smart contract for minting and managing ERC721 NFTs.\n * @dev The entire logic and functionality of the smart contract is self-contained.\n */\ncontract CxipERC721 {\n    /**\n     * @dev Stores default collection data: name, symbol, and royalties.\n     */\n    CollectionData private _collectionData;\n\n    /**\n     * @dev Internal last minted token id, to allow for auto-increment.\n     */\n    uint256 private _currentTokenId;\n\n    /**\n     * @dev Array of all token ids in collection.\n     */\n    uint256[] private _allTokens;\n\n    /**\n     * @dev Map of token id to array index of _ownedTokens.\n     */\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    /**\n     * @dev Token id to wallet (owner) address map.\n     */\n    mapping(uint256 => address) private _tokenOwner;\n\n    /**\n     * @dev 1-to-1 map of token id that was assigned an approved operator address.\n     */\n    mapping(uint256 => address) private _tokenApprovals;\n\n    /**\n     * @dev Map of total tokens owner by a specific address.\n     */\n    mapping(address => uint256) private _ownedTokensCount;\n\n    /**\n     * @dev Map of array of token ids owned by a specific address.\n     */\n    mapping(address => uint256[]) private _ownedTokens;\n\n    /**\n     * @notice Map of full operator approval for a particular address.\n     * @dev Usually utilised for supporting marketplace proxy wallets.\n     */\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Token data mapped by token id.\n     */\n    mapping(uint256 => TokenData) private _tokenData;\n\n    /**\n     * @dev Address of admin user. Primarily used as an additional recover address.\n     */\n    address private _admin;\n\n    /**\n     * @dev Address of contract owner. This address can run all onlyOwner functions.\n     */\n    address private _owner;\n\n    /**\n     * @dev Simple tracker of all minted (not-burned) tokens.\n     */\n    uint256 private _totalTokens;\n\n    /**\n     * @notice Event emitted when an token is minted, transfered, or burned.\n     * @dev If from is empty, it's a mint. If to is empty, it's a burn. Otherwise, it's a transfer.\n     * @param from Address from where token is being transfered.\n     * @param to Address to where token is being transfered.\n     * @param tokenId Token id that is being minted, Transfered, or burned.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @notice Event emitted when an address delegates power, for a token, to another address.\n     * @dev Emits event that informs of address approving a third-party operator for a particular token.\n     * @param wallet Address of the wallet configuring a token operator.\n     * @param operator Address of the third-party operator approved for interaction.\n     * @param tokenId A specific token id that is being authorised to operator.\n     */\n    event Approval(address indexed wallet, address indexed operator, uint256 indexed tokenId);\n\n    /**\n     * @notice Event emitted when an address authorises an operator (third-party).\n     * @dev Emits event that informs of address approving/denying a third-party operator.\n     * @param wallet Address of the wallet configuring it's operator.\n     * @param operator Address of the third-party operator that interacts on behalf of the wallet.\n     * @param approved A boolean indicating whether approval was granted or revoked.\n     */\n    event ApprovalForAll(address indexed wallet, address indexed operator, bool approved);\n\n    /**\n     * @notice Constructor is empty and not utilised.\n     * @dev To make exact CREATE2 deployment possible, constructor is left empty. We utilize the \"init\" function instead.\n     */\n    constructor() {}\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"CXIP: caller not an owner\");\n        _;\n    }\n\n    /**\n     * @notice Receive is purposefully left blank to not have any out-of-gas errors.\n     */\n    receive() external payable {}\n\n    /**\n     * @notice Enables royaltiy functionality at the ERC721 level no other function matches the call.\n     * @dev See implementation of _royaltiesFallback.\n     */\n    fallback() external {\n        _royaltiesFallback();\n    }\n\n    /**\n     * @notice Gets the URI of the NFT on Arweave.\n     * @dev Concatenates 2 sections of the arweave URI.\n     * @param tokenId Id of the token.\n     * @return string The URI.\n     */\n    function arweaveURI(uint256 tokenId) external view returns (string memory) {\n        return\n            string(abi.encodePacked(\"https://arweave.cxip.dev/\", _tokenData[tokenId].arweave, _tokenData[tokenId].arweave2));\n    }\n\n    /**\n     * @notice Gets the URI of the NFT backup from CXIP.\n     * @dev Concatenates to https://nft.cxip.dev/.\n     * @return string The URI.\n     */\n    function contractURI() external view returns (string memory) {\n        return string(abi.encodePacked(\"https://nft.cxip.dev/\", Strings.toHexString(address(this)), \"/\"));\n    }\n\n    /**\n     * @notice Gets the creator's address.\n     * @dev If the token Id doesn't exist it will return zero address.\n     * @param tokenId Id of the token.\n     * @return address Creator's address.\n     */\n    function creator(uint256 tokenId) external view returns (address) {\n        return _tokenData[tokenId].creator;\n    }\n\n    /**\n     * @notice Gets the HTTP URI of the token.\n     * @dev Concatenates to the baseURI.\n     * @return string The URI.\n     */\n    function httpURI(uint256 tokenId) external view returns (string memory) {\n        return string(abi.encodePacked(baseURI(), \"/\", Strings.toHexString(tokenId)));\n    }\n\n    /**\n     * @notice Gets the IPFS URI\n     * @dev Concatenates to the IPFS domain.\n     * @param tokenId Id of the token.\n     * @return string The URI.\n     */\n    function ipfsURI(uint256 tokenId) external view returns (string memory) {\n        return string(abi.encodePacked(\"https://ipfs.cxip.dev/\", _tokenData[tokenId].ipfs, _tokenData[tokenId].ipfs2));\n    }\n\n    /**\n     * @notice Gets the name of the collection.\n     * @dev Uses two names to extend the max length of the collection name in bytes\n     * @return string The collection name.\n     */\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(Bytes.trim(_collectionData.name), Bytes.trim(_collectionData.name2)));\n    }\n\n    /**\n     * @notice Gets the hash of the NFT data used to create it.\n     * @dev Payload is used for verification.\n     * @param tokenId The Id of the token.\n     * @return bytes32 The hash.\n     */\n    function payloadHash(uint256 tokenId) external view returns (bytes32) {\n        return _tokenData[tokenId].payloadHash;\n    }\n\n    /**\n     * @notice Gets the signature of the signed NFT data used to create it.\n     * @dev Used for signature verification.\n     * @param tokenId The Id of the token.\n     * @return Verification a struct containing v, r, s values of the signature.\n     */\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory) {\n        return _tokenData[tokenId].payloadSignature;\n    }\n\n    /**\n     * @notice Gets the address of the creator.\n     * @dev The creator signs a payload while creating the NFT.\n     * @param tokenId The Id of the token.\n     * @return address The creator.\n     */\n    function payloadSigner(uint256 tokenId) external view returns (address) {\n        return _tokenData[tokenId].creator;\n    }\n\n    /**\n     * @notice Shows the interfaces the contracts support\n     * @dev Must add new 4 byte interface Ids here to acknowledge support\n     * @param interfaceId ERC165 style 4 byte interfaceId.\n     * @return bool True if supported.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        if (\n            interfaceId == 0x01ffc9a7 || // ERC165\n            interfaceId == 0x80ac58cd || // ERC721\n            // || interfaceId == 0x780e9d63 // ERC721Enumerable\n            interfaceId == 0x5b5e139f || // ERC721Metadata\n            interfaceId == 0x150b7a02 || // ERC721TokenReceiver\n            interfaceId == 0xe8a3d485 || // contractURI()\n            IPA1D(getRegistry().getPA1D()).supportsInterface(interfaceId)\n        ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Gets the collection's symbol.\n     * @dev Trims the symbol.\n     * @return string The symbol.\n     */\n    function symbol() external view returns (string memory) {\n        return string(Bytes.trim(_collectionData.symbol));\n    }\n\n    /**\n     * @notice Get's the URI of the token.\n     * @dev Defaults the the Arweave URI\n     * @param tokenId The Id of the token.\n     * @return string The URI.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        return\n            string(abi.encodePacked(\"https://arweave.cxip.dev/\", _tokenData[tokenId].arweave, _tokenData[tokenId].arweave2));\n    }\n\n    /**\n     * @notice Get list of tokens owned by wallet.\n     * @param wallet The wallet address to get tokens for.\n     * @return uint256[] Returns an array of token ids owned by wallet.\n     */\n    function tokensOfOwner(address wallet) external view returns (uint256[] memory) {\n        return _ownedTokens[wallet];\n    }\n\n    /**\n     * @notice Checks if a given hash matches a payload hash.\n     * @dev Uses sha256 instead of keccak.\n     * @param hash The hash to check.\n     * @param payload The payload prehashed.\n     * @return bool True if the hashes match.\n     */\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool) {\n        bytes32 thePayloadHash = sha256(payload);\n        return hash == thePayloadHash;\n    }\n\n    /**\n     * @notice Adds a new address to the token's approval list.\n     * @dev Requires the sender to be in the approved addresses.\n     * @param to The address to approve.\n     * @param tokenId The affected token.\n     */\n    function approve(address to, uint256 tokenId) public {\n        address tokenOwner = _tokenOwner[tokenId];\n        if (to != tokenOwner && _isApproved(msg.sender, tokenId)) {\n            _tokenApprovals[tokenId] = to;\n            emit Approval(tokenOwner, to, tokenId);\n        }\n    }\n\n    /**\n     * @notice Burns the token.\n     * @dev The sender must be the owner or approved.\n     * @param tokenId The token to burn.\n     */\n    function burn(uint256 tokenId) public {\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\n        address wallet = _tokenOwner[tokenId];\n        _clearApproval(tokenId);\n        _tokenOwner[tokenId] = address(0);\n        emit Transfer(wallet, address(0), tokenId);\n        _removeTokenFromOwnerEnumeration(wallet, tokenId);\n    }\n\n    /**\n     * @notice Initializes the collection.\n     * @dev Special function to allow a one time initialisation on deployment. Also configures and deploys royalties.\n     * @param newOwner The owner of the collection.\n     * @param collectionData The collection data.\n     */\n    function init(address newOwner, CollectionData calldata collectionData) public {\n        require(Address.isZero(_admin), \"CXIP: already initialized\");\n        _admin = msg.sender;\n        // temporary set to self, to pass rarible royalties logic trap\n        _owner = address(this);\n        _collectionData = collectionData;\n        IPA1D(address(this)).init(0, payable(collectionData.royalties), collectionData.bps);\n        // set to actual owner\n        _owner = newOwner;\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     * @param from cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must exist and be owned by `from`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @notice Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     * @param from cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must exist and be owned by `from`.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public payable {\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\n        _transferFrom(from, to, tokenId);\n        if (Address.isContract(to)) {\n            require(\n                IERC165(to).supportsInterface(0x01ffc9a7) &&\n                    IERC165(to).supportsInterface(0x150b7a02) &&\n                    ICxipERC721(to).onERC721Received(address(this), from, tokenId, data) == 0x150b7a02,\n                \"CXIP: onERC721Received fail\"\n            );\n        }\n    }\n\n    /**\n     * @notice Adds a new approved operator.\n     * @dev Allows platforms to sell/transfer all your NFTs. Used with proxy contracts like OpenSea/Rarible.\n     * @param to The address to approve.\n     * @param approved Turn on or off approval status.\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender, \"CXIP: can't approve self\");\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * @param from  cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must be owned by `from`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public payable {\n        transferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @notice Transfers `tokenId` token from `from` to `to`.\n     * @dev WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n     * @param from  cannot be the zero address.\n     * @param to cannot be the zero address.\n     * @param tokenId token must be owned by `from`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory /*_data*/\n    ) public payable {\n        require(_isApproved(msg.sender, tokenId), \"CXIP: not approved sender\");\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @notice Mints and NFT.\n     * @dev Includes event with the Arwave token URI.\n     * @param id The new tokenId.\n     * @param tokenData The token data for the NFT.\n     * @return uint256 The new tokenId.\n     */\n    function cxipMint(uint256 id, TokenData calldata tokenData) public onlyOwner returns (uint256) {\n        if (id == 0) {\n            while (_exists(_currentTokenId)) {\n                _currentTokenId += 1;\n            }\n            id = _currentTokenId;\n        }\n        _mint(tokenData.creator, id);\n        _tokenData[id] = tokenData;\n        return id;\n    }\n\n    /**\n     * @notice Sets a name for the collection.\n     * @dev The name is split in two for gas optimization.\n     * @param newName First part of name.\n     * @param newName2 Second part of name.\n     */\n    function setName(bytes32 newName, bytes32 newName2) public onlyOwner {\n        _collectionData.name = newName;\n        _collectionData.name2 = newName2;\n    }\n\n    /**\n     * @notice Set a symbol for the collection.\n     * @dev This is the ticker symbol for smart contract that shows up on EtherScan.\n     * @param newSymbol The ticker symbol to set for smart contract.\n     */\n    function setSymbol(bytes32 newSymbol) public onlyOwner {\n        _collectionData.symbol = newSymbol;\n    }\n\n    /**\n     * @notice Get total number of tokens owned by wallet.\n     * @dev Used to see total amount of tokens owned by a specific wallet.\n     * @param wallet Address for which to get token balance.\n     * @return uint256 Returns an integer, representing total amount of tokens held by address.\n     */\n    function balanceOf(address wallet) public view returns (uint256) {\n        return _ownedTokensCount[wallet];\n    }\n\n    /**\n     * @notice Get a base URI for the token.\n     * @dev Concatenates with the CXIP domain name.\n     * @return string the token URI.\n     */\n    function baseURI() public view returns (string memory) {\n        return string(abi.encodePacked(\"https://cxip.dev/nft/\", Strings.toHexString(address(this))));\n    }\n\n    /**\n     * @notice Gets the approved address for the token.\n     * @dev Single operator set for a specific token. Usually used for one-time very specific authorisations.\n     * @param tokenId Token id to get approved operator for.\n     * @return address Approved address for token.\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @notice Checks if the address is approved.\n     * @dev Includes references to OpenSea and Rarible marketplace proxies.\n     * @param wallet Address of the wallet.\n     * @param operator Address of the marketplace operator.\n     * @return bool True if approved.\n     */\n    function isApprovedForAll(address wallet, address operator) public view returns (bool) {\n        return _operatorApprovals[wallet][operator];\n    }\n\n    /**\n     * @notice Check if the sender is the owner.\n     * @dev The owner could also be the admin or identity contract of the owner.\n     * @return bool True if owner.\n     */\n    function isOwner() public view returns (bool) {\n        return (msg.sender == _owner || msg.sender == _admin);\n    }\n\n    /**\n     * @notice Check if the address is the owner.\n     * @dev The owner could also be the admin or identity contract of the owner.\n     * @return bool True if owner.\n     */\n    function isOwner(address wallet) public view returns (bool) {\n        return (wallet == _owner || wallet == _admin);\n    }\n\n    /**\n     * @notice Gets the owner's address.\n     * @dev _owner is first set in init.\n     * @return address Of ower.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @notice Checks who the owner of a token is.\n     * @dev The token must exist.\n     * @param tokenId The token to look up.\n     * @return address Owner of the token.\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address tokenOwner = _tokenOwner[tokenId];\n        require(!Address.isZero(tokenOwner), \"ERC721: token does not exist\");\n        return tokenOwner;\n    }\n\n    /**\n     * @notice Get token by index instead of token id.\n     * @dev Helpful for token enumeration where token id info is not yet available.\n     * @param index Index of token in array.\n     * @return uint256 Returns the token id of token located at that index.\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply(), \"CXIP: index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @notice Get token from wallet by index instead of token id.\n     * @dev Helpful for wallet token enumeration where token id info is not yet available. Use in conjunction with balanceOf function.\n     * @param wallet Specific address for which to get token for.\n     * @param index Index of token in array.\n     * @return uint256 Returns the token id of token located at that index in specified wallet.\n     */\n    function tokenOfOwnerByIndex(address wallet, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(wallet), \"CXIP: index out of bounds\");\n        return _ownedTokens[wallet][index];\n    }\n\n    /**\n     * @notice Total amount of tokens in the collection.\n     * @dev Ignores burned tokens.\n     * @return uint256 Returns the total number of active (not burned) tokens.\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalTokens;\n    }\n\n    /**\n     * @notice Empty function that is triggered by external contract on NFT transfer.\n     * @dev We have this blank function in place to make sure that external contract sending in NFTs don't error out.\n     * @dev Since it's not being used, the _operator variable is commented out to avoid compiler warnings.\n     * @dev Since it's not being used, the _from variable is commented out to avoid compiler warnings.\n     * @dev Since it's not being used, the _tokenId variable is commented out to avoid compiler warnings.\n     * @dev Since it's not being used, the _data variable is commented out to avoid compiler warnings.\n     * @return bytes4 Returns the interfaceId of onERC721Received.\n     */\n    function onERC721Received(\n        address, /*_operator*/\n        address, /*_from*/\n        uint256, /*_tokenId*/\n        bytes calldata /*_data*/\n    ) public pure returns (bytes4) {\n        return 0x150b7a02;\n    }\n\n    /**\n     * @notice Allows retrieval of royalties from the contract.\n     * @dev This is a default fallback to ensure the royalties are available.\n     */\n    function _royaltiesFallback() internal {\n        address _target = getRegistry().getPA1D();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da);\n    }\n\n    /**\n     * @dev Add a newly minted token into managed list of tokens.\n     * @param to Address of token owner for which to add the token.\n     * @param tokenId Id of token to add.\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokensCount[to];\n        _ownedTokensCount[to]++;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @notice Deletes a token from the approval list.\n     * @dev Removes from count.\n     * @param tokenId T.\n     */\n    function _clearApproval(uint256 tokenId) private {\n        delete _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @notice Mints an NFT.\n     * @dev Can to mint the token to the zero address and the token cannot already exist.\n     * @param to Address to mint to.\n     * @param tokenId The new token.\n     */\n    function _mint(address to, uint256 tokenId) private {\n        if (Address.isZero(to) || _exists(tokenId)) {\n            assert(false);\n        }\n        _tokenOwner[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n        _addTokenToOwnerEnumeration(to, tokenId);\n        _totalTokens += 1;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Remove a token from managed list of tokens.\n     * @param from Address of token owner for which to remove the token.\n     * @param tokenId Id of token to remove.\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        _ownedTokensCount[from]--;\n        uint256 lastTokenIndex = _ownedTokensCount[from];\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n            _ownedTokens[from][tokenIndex] = lastTokenId;\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\n        }\n        if (lastTokenIndex == 0) {\n            delete _ownedTokens[from];\n        } else {\n            delete _ownedTokens[from][lastTokenIndex];\n        }\n    }\n\n    /**\n     * @dev Primary internal function that handles the transfer/mint/burn functionality.\n     * @param from Address from where token is being transferred. Zero address means it is being minted.\n     * @param to Address to whom the token is being transferred. Zero address means it is being burned.\n     * @param tokenId Id of token that is being transferred/minted/burned.\n     */\n    function _transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) private {\n        if (_tokenOwner[tokenId] == from && !Address.isZero(to)) {\n            _clearApproval(tokenId);\n            _tokenOwner[tokenId] = to;\n            emit Transfer(from, to, tokenId);\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n            _addTokenToOwnerEnumeration(to, tokenId);\n        } else {\n            assert(false);\n        }\n    }\n\n    /**\n     * @notice Checks if the token owner exists.\n     * @dev If the address is the zero address no owner exists.\n     * @param tokenId The affected token.\n     * @return bool True if it exists.\n     */\n    function _exists(uint256 tokenId) private view returns (bool) {\n        address tokenOwner = _tokenOwner[tokenId];\n        return !Address.isZero(tokenOwner);\n    }\n\n    /**\n     * @notice Checks if the address is an approved one.\n     * @dev Uses inlined checks for different usecases of approval.\n     * @param spender Address of the spender.\n     * @param tokenId The affected token.\n     * @return bool True if approved.\n     */\n    function _isApproved(address spender, uint256 tokenId) private view returns (bool) {\n        require(_exists(tokenId));\n        address tokenOwner = _tokenOwner[tokenId];\n        return (spender == tokenOwner || getApproved(tokenId) == spender || isApprovedForAll(tokenOwner, spender));\n    }\n}\n"
    },
    "contracts/external/OpenSea.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ncontract OpenSeaOwnableDelegateProxy {}\n\ncontract OpenSeaProxyRegistry {\n    mapping(address => OpenSeaOwnableDelegateProxy) public proxies;\n}\n"
    },
    "contracts/interface/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/interface/ICxipERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../struct/CollectionData.sol\";\nimport \"../struct/TokenData.sol\";\nimport \"../struct/Verification.sol\";\n\ninterface ICxipERC721 {\n    function arweaveURI(uint256 tokenId) external view returns (string memory);\n\n    function contractURI() external view returns (string memory);\n\n    function creator(uint256 tokenId) external view returns (address);\n\n    function httpURI(uint256 tokenId) external view returns (string memory);\n\n    function ipfsURI(uint256 tokenId) external view returns (string memory);\n\n    function name() external view returns (string memory);\n\n    function payloadHash(uint256 tokenId) external view returns (bytes32);\n\n    function payloadSignature(uint256 tokenId) external view returns (Verification memory);\n\n    function payloadSigner(uint256 tokenId) external view returns (address);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n\n    function tokensOfOwner(address wallet) external view returns (uint256[] memory);\n\n    function verifySHA256(bytes32 hash, bytes calldata payload) external pure returns (bool);\n\n    function approve(address to, uint256 tokenId) external;\n\n    function burn(uint256 tokenId) external;\n\n    function init(address newOwner, CollectionData calldata collectionData) external;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable;\n\n    function setApprovalForAll(address to, bool approved) external;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external payable;\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external payable;\n\n    function cxipMint(uint256 id, TokenData calldata tokenData) external returns (uint256);\n\n    function setApprovalForAll(\n        address from,\n        address to,\n        bool approved\n    ) external;\n\n    function setName(bytes32 newName, bytes32 newName2) external;\n\n    function setSymbol(bytes32 newSymbol) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function balanceOf(address wallet) external view returns (uint256);\n\n    function baseURI() external view returns (string memory);\n\n    function getApproved(uint256 tokenId) external view returns (address);\n\n    function isApprovedForAll(address wallet, address operator) external view returns (bool);\n\n    function isOwner() external view returns (bool);\n\n    function isOwner(address wallet) external view returns (bool);\n\n    function owner() external view returns (address);\n\n    function ownerOf(uint256 tokenId) external view returns (address);\n\n    function tokenByIndex(uint256 index) external view returns (uint256);\n\n    function tokenOfOwnerByIndex(address wallet, uint256 index) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external pure returns (bytes4);\n}\n"
    },
    "contracts/interface/ICxipProvenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../struct/CollectionData.sol\";\nimport \"../struct/InterfaceType.sol\";\nimport \"../struct/Token.sol\";\nimport \"../struct/TokenData.sol\";\n\ninterface ICxipProvenance {\n    function createERC721Token(\n        address collection,\n        uint256 id,\n        TokenData calldata tokenData,\n        Verification calldata verification\n    ) external returns (uint256);\n\n    function createERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData\n    ) external returns (address);\n\n    function createCustomERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData,\n        bytes32 slot,\n        bytes memory bytecode\n    ) external returns (address);\n\n    function getCollectionById(uint256 index) external view returns (address);\n\n    function getCollectionType(address collection) external view returns (InterfaceType);\n\n    function isCollectionCertified(address collection) external view returns (bool);\n\n    function isCollectionRegistered(address collection) external view returns (bool);\n\n    function isTokenCertified(address collection, uint256 tokenId) external view returns (bool);\n\n    function isTokenRegistered(address collection, uint256 tokenId) external view returns (bool);\n\n    function listCollections(uint256 offset, uint256 length)\n        external\n        view\n        returns (address[] memory);\n\n    function totalCollections() external view returns (uint256);\n\n    function isCollectionOpen(address collection) external pure returns (bool);\n}\n"
    },
    "contracts/interface/ICxipRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface ICxipRegistry {\n    function getCustomSource(bytes32 name) external view returns (address);\n\n    function getCustomSourceFromString(string memory name) external view returns (address);\n\n    function getERC1155CollectionSource() external view returns (address);\n\n    function getERC721CollectionSource() external view returns (address);\n\n    function getPA1D() external view returns (address);\n\n    function getPA1DSource() external view returns (address);\n\n    function getProvenance() external view returns (address);\n\n    function getProvenanceSource() external view returns (address);\n\n    function owner() external view returns (address);\n\n    function setCustomSource(string memory name, address source) external;\n\n    function setERC1155CollectionSource(address source) external;\n\n    function setERC721CollectionSource(address source) external;\n\n    function setPA1D(address proxy) external;\n\n    function setPA1DSource(address source) external;\n\n    function setProvenance(address proxy) external;\n\n    function setProvenanceSource(address source) external;\n}\n"
    },
    "contracts/interface/IPA1D.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../library/Zora.sol\";\n\ninterface IPA1D {\n    function init(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) external;\n\n    function configurePayouts(address payable[] memory addresses, uint256[] memory bps) external;\n\n    function getPayoutInfo()\n        external\n        view\n        returns (address payable[] memory addresses, uint256[] memory bps);\n\n    function getEthPayout() external;\n\n    function getTokenPayout(address tokenAddress) external;\n\n    function getTokenPayoutByName(string memory tokenName) external;\n\n    function getTokensPayout(address[] memory tokenAddresses) external;\n\n    function getTokensPayoutByName(string[] memory tokenNames) external;\n\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool);\n\n    function setRoyalties(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) external;\n\n    function royaltyInfo(uint256 tokenId, uint256 value) external view returns (address, uint256);\n\n    function getFeeBps(uint256 tokenId) external view returns (uint256[] memory);\n\n    function getFeeRecipients(uint256 tokenId) external view returns (address payable[] memory);\n\n    function getRoyalties(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n\n    function getFees(uint256 tokenId)\n        external\n        view\n        returns (address payable[] memory, uint256[] memory);\n\n    function tokenCreator(address contractAddress, uint256 tokenId) external view returns (address);\n\n    function calculateRoyaltyFee(\n        address contractAddress,\n        uint256 tokenId,\n        uint256 amount\n    ) external view returns (uint256);\n\n    function marketContract() external view returns (address);\n\n    function tokenCreators(uint256 tokenId) external view returns (address);\n\n    function bidSharesForToken(uint256 tokenId)\n        external\n        view\n        returns (Zora.BidShares memory bidShares);\n\n    function getStorageSlot(string calldata slot) external pure returns (bytes32);\n\n    function getTokenAddress(string memory tokenName) external view returns (address);\n}\n"
    },
    "contracts/library/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Address {\n    function isContract(address account) internal view returns (bool) {\n        bytes32 codehash;\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != 0x0 &&\n            codehash != 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\n    }\n\n    function isZero(address account) internal pure returns (bool) {\n        return (account == address(0));\n    }\n}\n"
    },
    "contracts/library/Bytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Bytes {\n    function getBoolean(uint192 _packedBools, uint192 _boolNumber) internal pure returns (bool) {\n        uint192 flag = (_packedBools >> _boolNumber) & uint192(1);\n        return (flag == 1 ? true : false);\n    }\n\n    function setBoolean(\n        uint192 _packedBools,\n        uint192 _boolNumber,\n        bool _value\n    ) internal pure returns (uint192) {\n        if (_value) {\n            return _packedBools | (uint192(1) << _boolNumber);\n        } else {\n            return _packedBools & ~(uint192(1) << _boolNumber);\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n        bytes memory tempBytes;\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                tempBytes := mload(0x40)\n                let lengthmod := and(_length, 31)\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n                for {\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n                mstore(tempBytes, _length)\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            default {\n                tempBytes := mload(0x40)\n                mstore(tempBytes, 0)\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n        return tempBytes;\n    }\n\n    function trim(bytes32 source) internal pure returns (bytes memory) {\n        uint256 temp = uint256(source);\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return slice(abi.encodePacked(source), 32 - length, length);\n    }\n}\n"
    },
    "contracts/library/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Strings {\n    function toHexString(address account) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(account)));\n    }\n\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = bytes16(\"0123456789abcdef\")[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/struct/CollectionData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./UriType.sol\";\n\nstruct CollectionData {\n    bytes32 name;\n    bytes32 name2;\n    bytes32 symbol;\n    address royalties;\n    uint96 bps;\n}\n"
    },
    "contracts/struct/TokenData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./Verification.sol\";\n\nstruct TokenData {\n    bytes32 payloadHash;\n    Verification payloadSignature;\n    address creator;\n    bytes32 arweave;\n    bytes11 arweave2;\n    bytes32 ipfs;\n    bytes14 ipfs2;\n}\n"
    },
    "contracts/struct/Verification.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nstruct Verification {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n}\n"
    },
    "contracts/struct/UriType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\n// This is a 256 value limit (uint8)\nenum UriType {\n    ARWEAVE, // 0\n    IPFS, // 1\n    HTTP // 2\n}\n"
    },
    "contracts/struct/InterfaceType.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\n// This is a 256 value limit (uint8)\nenum InterfaceType {\n    NULL, // 0\n    ERC20, // 1\n    ERC721, // 2\n    ERC1155 // 3\n}\n"
    },
    "contracts/struct/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./InterfaceType.sol\";\n\nstruct Token {\n    address collection;\n    uint256 tokenId;\n    InterfaceType tokenType;\n    address creator;\n}\n"
    },
    "contracts/library/Zora.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Zora {\n    struct Decimal {\n        uint256 value;\n    }\n\n    struct BidShares {\n        // % of sale value that goes to the _previous_ owner of the nft\n        Decimal prevOwner;\n        // % of sale value that goes to the original creator of the nft\n        Decimal creator;\n        // % of sale value that goes to the seller (current owner) of the nft\n        Decimal owner;\n    }\n}\n"
    },
    "contracts/struct/MintData.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./Verification.sol\";\n\nstruct MintData {\n    uint256 id;\n    bytes32 payloadHash;\n    Verification payloadSig;\n    bytes32 arweave;\n    bytes11 arweave2;\n    bytes32 ipfs;\n    bytes14 ipfs2;\n}\n"
    },
    "contracts/CxipProvenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./interface/ICxipERC721.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./library/Address.sol\";\nimport \"./library/Signature.sol\";\nimport \"./struct/CollectionData.sol\";\nimport \"./struct/InterfaceType.sol\";\nimport \"./struct/Token.sol\";\nimport \"./struct/TokenData.sol\";\nimport \"./struct/Verification.sol\";\n\n/**\n * @title CXIP Provenance\n * @author CXIP-Labs\n * @notice A smart contract for managing and validating all of CXIP's provenance.\n * @dev For a CXIP Identity to be valid, it needs to be made through CXIP Provenance.\n */\ncontract CxipProvenance {\n    /**\n     * @dev Reentrancy implementation from OpenZepellin. State 1 == NOT_ENDERED, State 2 == ENTERED\n     */\n    uint256 private _reentrancyState;\n\n    /**\n     * @dev Array of addresses for all collection that were created by the identity.\n     */\n    address[] private _collectionArray;\n\n    /**\n     * @dev Map with interface type definitions for identity created collections.\n     */\n    mapping(address => InterfaceType) private _additionalInfo;\n\n    /**\n     * @notice Event emitted when a collection is created.\n     * @dev Allows off-chain services to index the newly deployed collection address.\n     * @param collectionCreator Address of the collection creator (msg.sender).\n     * @param collectionAddress Address of the newly created collection.\n     * @param salt A salt used for deploying a collection to a specific address.\n     */\n    event CollectionCreated(address indexed collectionCreator, address indexed collectionAddress, bytes32 indexed salt);\n\n    /**\n     * @notice Constructor is empty and only reentrancy guard is implemented.\n     * @dev There is no data that needs to be set on first time deployment.\n     */\n    constructor() {\n        _reentrancyState = 1;\n    }\n\n    /**\n     * @dev Implementation from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\n     */\n    modifier nonReentrant() {\n        require(_reentrancyState != 2, \"ReentrancyGuard: reentrant call\");\n        _reentrancyState = 2;\n        _;\n        _reentrancyState = 1;\n    }\n\n    /**\n     * @notice Check if an identity collection is open to external minting.\n     * @dev For now this always returns false. Left as a placeholder for future development where shared collections might be used.\n     * @dev Since it's not being used, the collection variable is commented out to avoid compiler warnings.\n     * @return bool Returns true of false, to indicate if a specific collection is open/shared.\n     */\n    function isCollectionOpen(\n        address/* collection*/\n    ) external pure returns (bool) {\n        return false;\n    }\n\n    /**\n     * @notice Create an ERC721 collection.\n     * @dev Creates and associates the ERC721 collection with the identity.\n     * @param saltHash A salt used for deploying a collection to a specific address.\n     * @param collectionCreator Specific wallet, associated with the identity, that will be marked as the creator of this collection.\n     * @param verification Signature created by the collectionCreator wallet to validate the integrity of the collection data.\n     * @param collectionData The collection data struct, with all the default collection info.\n     * @return address Returns the address of the newly created collection.\n     */\n    function createERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData\n    ) public nonReentrant returns (address) {\n        if(collectionCreator != msg.sender) {\n            require(\n                Signature.Valid(\n                    collectionCreator,\n                    verification.r,\n                    verification.s,\n                    verification.v,\n                    abi.encodePacked(\n                        address(this),\n                        collectionCreator,\n                        collectionData.name,\n                        collectionData.name2,\n                        collectionData.symbol,\n                        collectionData.royalties,\n                        collectionData.bps\n                    )\n                ),\n                \"CXIP: invalid signature\"\n            );\n        }\n        bytes memory bytecode = hex\"608060405234801561001057600080fd5b5060f68061001f6000396000f3fe60806040819052632c5feccb60e11b815260009073415225c0d082cb195aee69f490c218def30966da906358bfd99690608490602090600481865afa158015604b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190606d91906092565b90503660008037600080366000845af43d6000803e808015608d573d6000f35b3d6000fd5b60006020828403121560a357600080fd5b81516001600160a01b038116811460b957600080fd5b939250505056fea26469706673582212207e3850d5f5eaab2151a5f3470e98fd3411f6eec0c0f906020ffeecad3294dabd64736f6c634300080c0033\";\n        address cxipAddress;\n        assembly {\n            cxipAddress := create2(\n                0,\n                add(bytecode, 0x20),\n                mload(bytecode),\n                saltHash\n            )\n        }\n        ICxipERC721(cxipAddress).init(collectionCreator, collectionData);\n        _addCollectionToEnumeration(cxipAddress, InterfaceType.ERC721);\n        emit CollectionCreated(collectionCreator, cxipAddress, saltHash);\n        return(cxipAddress);\n    }\n\n    /**\n     * @notice Create a custom ERC721 collection.\n     * @dev Creates and associates the custom ERC721 collection with the identity.\n     * @param saltHash A salt used for deploying a collection to a specific address.\n     * @param collectionCreator Specific wallet, associated with the identity, that will be marked as the creator of this collection.\n     * @param verification Signature created by the collectionCreator wallet to validate the integrity of the collection data.\n     * @param collectionData The collection data struct, with all the default collection info.\n     * @param slot Hash of proxy contract slot where the source is saved in registry.\n     * @param bytecode The bytecode used for deployment. Validated against slot code for abuse prevention.\n     * @return address Returns the address of the newly created collection.\n     */\n    function createCustomERC721Collection(\n        bytes32 saltHash,\n        address collectionCreator,\n        Verification calldata verification,\n        CollectionData calldata collectionData,\n        bytes32 slot,\n        bytes memory bytecode\n    ) public nonReentrant returns (address) {\n        if(collectionCreator != msg.sender) {\n            require(\n                Signature.Valid(\n                    collectionCreator,\n                    verification.r,\n                    verification.s,\n                    verification.v,\n                    abi.encodePacked(\n                        address(this),\n                        collectionCreator,\n                        collectionData.name,\n                        collectionData.name2,\n                        collectionData.symbol,\n                        collectionData.royalties,\n                        collectionData.bps\n                    )\n                ),\n                \"CXIP: invalid signature\"\n            );\n        }\n        address cxipAddress;\n        assembly {\n            cxipAddress := create2(\n                0,\n                add(bytecode, 0x20),\n                mload(bytecode),\n                saltHash\n            )\n        }\n        require(\n            keccak256(cxipAddress.code) == keccak256(ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da).getCustomSource(slot).code),\n            \"CXIP: byte code missmatch\"\n        );\n        ICxipERC721(cxipAddress).init(collectionCreator, collectionData);\n        _addCollectionToEnumeration(cxipAddress, InterfaceType.ERC721);\n        emit CollectionCreated(collectionCreator, cxipAddress, saltHash);\n        return(cxipAddress);\n    }\n\n    /**\n     * @dev This retrieves a collection by index. Don't be confused by the ID in the title.\n     * @param index Index of the item to get from the array.\n     * @return address Returns the collection contract address at that index of array.\n     */\n    function getCollectionById(uint256 index) public view returns (address) {\n        return _collectionArray[index];\n    }\n\n    /**\n     * @notice Get the collection's Interface Type: ERC20, ERC721, ERC1155.\n     * @dev Collection must be associated with identity.\n     * @param collection Contract address of the collection.\n     * @return InterfaceType Returns an enum (uint8) of the collection interface type.\n     */\n    function getCollectionType(address collection) public view returns (InterfaceType) {\n        return _additionalInfo[collection];\n    }\n\n    /**\n     * @dev Reserved function for later use. Will be used to identify if collection was heavily vetted.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with the identity.\n     */\n    function isCollectionCertified(\n        address collection\n    ) public view returns (bool) {\n        return _isCollectionValid(collection);\n    }\n\n    /**\n     * @notice Check if a collection is registered with identity.\n     * @dev For now will only return true for collections created directly from the identity contract.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with the identity.\n     */\n    function isCollectionRegistered(\n        address collection\n    ) public view returns (bool) {\n        return _isCollectionValid(collection);\n    }\n\n    /**\n     * @dev Reserved function for later use. Will be used to identify if token was heavily vetted.\n     * @param collection Contract address of the collection.\n     * @param tokenId Id of the token.\n     * @return bool Returns true if token is associated with the identity.\n     */\n    function isTokenCertified(\n        address collection,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return _isValidToken(collection, tokenId);\n    }\n\n    /**\n     * @notice Check if a token is registered with identity.\n     * @dev For now will only return true for tokens created directly from the identity contract.\n     * @param collection Contract address of the collection.\n     * @param tokenId Id of the token.\n     * @return bool Returns true if token is associated with the identity.\n     */\n    function isTokenRegistered(\n        address collection,\n        uint256 tokenId\n    ) public view returns (bool) {\n        return _isValidToken(collection, tokenId);\n    }\n\n    /**\n     * @notice List all collections associated with this identity.\n     * @dev Use in conjunction with the totalCollections function, for pagination.\n     * @param offset Index from where to start pagination. Start at 0.\n     * @param length Length of slice to return, starting from offset index.\n     * @return address[] Returns a fixed length array starting from offset.\n     */\n    function listCollections(\n        uint256 offset,\n        uint256 length\n    ) public view returns (address[] memory) {\n        uint256 limit = offset + length;\n        if(limit > _collectionArray.length) {\n            limit = _collectionArray.length;\n        }\n        address[] memory collections = new address[](limit - offset);\n        uint256 n = 0;\n        for(uint256 i = offset; i < limit; i++) {\n            collections[n] = _collectionArray[i];\n            n++;\n        }\n        return collections;\n    }\n\n    /**\n     * @notice Get total number of collections associated with this identity.\n     * @dev Use in conjunction with the listCollections, for pagination.\n     * @return uint256 Returns the total length of collections.\n     */\n    function totalCollections() public view returns (uint256) {\n        return _collectionArray.length;\n    }\n\n    /**\n     * @dev Add collection to identity.\n     * @param collection Contract address of the collection to add.\n     * @param collectionType Interface type of the collection being added.\n     */\n    function _addCollectionToEnumeration(\n        address collection,\n        InterfaceType collectionType\n    ) internal {\n        _collectionArray.push(collection);\n        _additionalInfo[collection] = collectionType;\n    }\n\n    /**\n     * @dev Remove collection from identity.\n     * @param index Array index of the collection to remove.\n     */\n    function _removeCollectionFromEnumeration(uint256 index) internal {\n        require(\n            _collectionArray.length != 0,\n            \"CXIP: removing from empty array\"\n        );\n        delete _additionalInfo[_collectionArray[index]];\n        uint256 lastIndex = _collectionArray.length - 1;\n        if(lastIndex != 0) {\n            if(index != lastIndex) {\n                address lastCollection = _collectionArray[lastIndex];\n                _collectionArray[index] = lastCollection;\n            }\n        }\n        if(lastIndex == 0) {\n            delete _collectionArray;\n        } else {\n            delete _collectionArray[lastIndex];\n        }\n    }\n\n    /**\n     * @dev Check if collection is associated with this identity.\n     * @param collection Contract address of the collection.\n     * @return bool Returns true if collection is associated with this identity.\n     */\n    function _isCollectionValid(\n        address collection\n    ) internal view returns (bool) {\n        return _additionalInfo[collection] != InterfaceType.NULL;\n    }\n\n    /**\n     * @dev Check if token is associated with this identity.\n     * @param collection Contract address of the collection.\n     * @dev Since it's not being used yet, the tokenId variable is commented out to avoid compiler warnings.\n     * @return bool Returns true if token is associated with this identity.\n     */\n    function _isValidToken(\n        address collection,\n        uint256/* tokenId*/\n    ) internal view returns (bool) {\n        return _additionalInfo[collection] != InterfaceType.NULL;\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return ICxipRegistry The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da);\n    }\n}\n"
    },
    "contracts/library/Signature.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nlibrary Signature {\n    function Derive(\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        bytes memory encoded\n    )\n        internal\n        pure\n        returns (\n            address derived1,\n            address derived2,\n            address derived3,\n            address derived4\n        )\n    {\n        bytes32 encoded32;\n        assembly {\n            encoded32 := mload(add(encoded, 32))\n        }\n        derived1 = ecrecover(encoded32, v, r, s);\n        derived2 = ecrecover(\n            keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)),\n            v,\n            r,\n            s\n        );\n        encoded32 = keccak256(encoded);\n        derived3 = ecrecover(encoded32, v, r, s);\n        encoded32 = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32));\n        derived4 = ecrecover(encoded32, v, r, s);\n    }\n\n    function PackMessage(bytes memory encoded, bool geth) internal pure returns (bytes32) {\n        bytes32 hash = keccak256(encoded);\n        if (geth) {\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        }\n        return hash;\n    }\n\n    function Valid(\n        address target,\n        bytes32 r,\n        bytes32 s,\n        uint8 v,\n        bytes memory encoded\n    ) internal pure returns (bool) {\n        bytes32 encoded32;\n        address derived;\n        if (encoded.length == 32) {\n            assembly {\n                encoded32 := mload(add(encoded, 32))\n            }\n            derived = ecrecover(encoded32, v, r, s);\n            if (target == derived) {\n                return true;\n            }\n            derived = ecrecover(\n                keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", encoded32)),\n                v,\n                r,\n                s\n            );\n            if (target == derived) {\n                return true;\n            }\n        }\n        bytes32 hash = keccak256(encoded);\n        derived = ecrecover(hash, v, r, s);\n        if (target == derived) {\n            return true;\n        }\n        hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n        derived = ecrecover(hash, v, r, s);\n        return target == derived;\n    }\n}\n"
    },
    "contracts/struct/CollectionInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./InterfaceType.sol\";\n\nstruct CollectionInfo {\n    InterfaceType interfaceType;\n    bool valid;\n    bool open;\n    bool certified;\n}\n"
    },
    "contracts/external/MockERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\nimport \"../interface/ICxipERC721.sol\";\nimport \"../interface/IERC165.sol\";\nimport \"../interface/IERC721Receiver.sol\";\n\ncontract MockERC721Receiver is IERC165, IERC721Receiver {\n\n    bool private _works;\n\n    constructor () {\n        _works = true;\n    }\n\n    function toggleWorks(bool active) external {\n        _works = active;\n    }\n\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\n        if (interfaceID == 0x01ffc9a7 || interfaceID == 0x150b7a02) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function onERC721Received(\n        address /*operator*/,\n        address /*from*/,\n        uint256 /*tokenId*/,\n        bytes calldata /*data*/\n    ) external view returns (bytes4) {\n        if (_works) {\n            return 0x150b7a02;\n        } else {\n            return 0x00000000;\n        }\n    }\n\n    function transferNFT(address payable token, uint256 tokenId, address to) external {\n        ICxipERC721(token).safeTransferFrom(address(this), to, tokenId);\n    }\n\n}\n"
    },
    "contracts/interface/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\ninterface IERC721Receiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "contracts/PA1D.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"./library/Address.sol\";\nimport \"./library/Zora.sol\";\nimport \"./interface/IERC20.sol\";\nimport \"./interface/ICxipRegistry.sol\";\nimport \"./interface/ICxipERC.sol\";\n\n/**\n * @title PA1D (CXIP)\n * @author CXIP-Labs\n * @notice A smart contract for providing royalty info, collecting royalties, and distributing it to configured payout wallets.\n * @dev This smart contract is not intended to be used directly. Apply it to any of your ERC721 or ERC1155 smart contracts through a delegatecall fallback.\n */\ncontract PA1D {\n    /**\n     * @notice Event emitted when setting/updating royalty info/fees. This is used by Rarible V1.\n     * @dev Emits event in order to comply with Rarible V1 royalty spec.\n     * @param tokenId Specific token id for which royalty info is being set, set as 0 for all tokens inside of the smart contract.\n     * @param recipients Address array of wallets that will receive tha royalties.\n     * @param bps Uint256 array of base points(percentages) that each wallet(specified in recipients) will receive from the royalty payouts. Make sure that all the base points add up to a total of 10000.\n     */\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint256[] bps);\n\n    /**\n     * @dev Use this modifier to lock public functions that should not be accesible to non-owners.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"PA1D: caller not an owner\");\n        _;\n    }\n\n    /**\n     * @notice Constructor is empty and not utilised.\n     * @dev Since the smart contract is being used inside of a fallback context, the constructor function is not being used.\n     */\n    constructor() {}\n\n    /**\n     * @notice Initialise the smart contract on source smart contract deployment/initialisation.\n     * @dev Use the init function once, when deploying or initialising your overlying smart contract.\n     * @dev Take great care to not expose this function to your other public functions.\n     * @param tokenId Specify a particular token id only if using the init function for a special case. Otherwise leave empty(0).\n     * @param receiver The address for the default receiver of all royalty payouts. Recommended to use the overlying smart contract address. This will allow the PA1D smart contract to handle all royalty settings, receipt, and distribution.\n     * @param bp The default base points(percentage) for royalty payouts.\n     */\n    function init(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) public onlyOwner {\n        //         if (Address.isZero(receiver)) {\n        //             receiver = payable(this);\n        //         }\n        //         setRoyalties(tokenId, receiver, bp);\n        //         // We register the smart contract with Rarible(V1) as the controller for royalties.\n        //         // This makes sure that all royalty info will be queried from the contract and not somewhere else\n        //         /**\n        //          * @dev Keep in mind that Rarible V1 makes a \"owner\" function call to the overlying smart contract.\n        //          * @dev It is mandatory to have owner function call return this contract address, or the function will fail.\n        //          */\n        //         (\n        //             bool setProviderSuccess, /*bytes memory setProviderResponse*/\n        //         ) = address(0x20202052617269626C6520526F79616c74696573).call(\n        //                 /**\n        //                  * @dev We hardcode the bytes4 function hash to save on gas\n        //                  */\n        //                 // abi.encodeWithSignature(\n        //                 //     'setProviderByToken(address,address)',\n        //                 abi.encodeWithSelector(bytes4(0xd836f013), address(this), address(this))\n        //             );\n        //         require(setProviderSuccess, \"PA1D: failed setting Rarible\");\n    }\n\n    /**\n     * @dev Get the top-level CXIP Registry smart contract. Function must always be internal to prevent miss-use/abuse through bad programming practices.\n     * @return The address of the top-level CXIP Registry smart contract.\n     */\n    function getRegistry() internal pure returns (ICxipRegistry) {\n        return ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da);\n    }\n\n    /**\n     * @notice Check if message sender is a legitimate owner of the smart contract\n     * @dev We check owner, admin, and identity for a more comprehensive coverage.\n     * @return Returns true is message sender is an owner.\n     */\n    function isOwner() internal view returns (bool) {\n        return ICxipERC(address(this)).isOwner(msg.sender);\n    }\n\n    /**\n     * @dev Gets the default royalty payment receiver address from storage slot.\n     * @return receiver Wallet or smart contract that will receive the initial royalty payouts.\n     */\n    function _getDefaultReceiver() internal view returns (address payable receiver) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultReceiver')) - 1);\n        assembly {\n            receiver := sload(\n                /* slot */\n                0xaee4e97c19ce50ea5345ba9751676d533a3a7b99c3568901208f92f9eea6a7f2\n            )\n        }\n    }\n\n    /**\n     * @dev Sets the default royalty payment receiver address to storage slot.\n     * @param receiver Wallet or smart contract that will receive the initial royalty payouts.\n     */\n    function _setDefaultReceiver(address receiver) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultReceiver')) - 1);\n        assembly {\n            sstore(\n                /* slot */\n                0xaee4e97c19ce50ea5345ba9751676d533a3a7b99c3568901208f92f9eea6a7f2,\n                receiver\n            )\n        }\n    }\n\n    /**\n     * @dev Gets the default royalty base points(percentage) from storage slot.\n     * @return bp Royalty base points(percentage) for royalty payouts.\n     */\n    function _getDefaultBp() internal view returns (uint256 bp) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultBp')) - 1);\n        assembly {\n            bp := sload(\n                /* slot */\n                0xfd198c3b406b2320ea9f4a413c7a69a7592dbfc4175b8c252fec24223e68b720\n            )\n        }\n    }\n\n    /**\n     * @dev Sets the default royalty base points(percentage) to storage slot.\n     * @param bp Uint256 of royalty percentage, provided in base points format.\n     */\n    function _setDefaultBp(uint256 bp) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.defaultBp')) - 1);\n        assembly {\n            sstore(\n                /* slot */\n                0xfd198c3b406b2320ea9f4a413c7a69a7592dbfc4175b8c252fec24223e68b720,\n                bp\n            )\n        }\n    }\n\n    /**\n     * @dev Gets the royalty payment receiver address, for a particular token id, from storage slot.\n     * @return receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n     */\n    function _getReceiver(uint256 tokenId) internal view returns (address payable receiver) {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.receiver\", tokenId))) - 1\n        );\n        assembly {\n            receiver := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the royalty payment receiver address, for a particular token id, to storage slot.\n     * @param tokenId Uint256 of the token id to set the receiver for.\n     * @param receiver Wallet or smart contract that will receive the royalty payouts for a particular token id.\n     */\n    function _setReceiver(uint256 tokenId, address receiver) internal {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.receiver\", tokenId))) - 1\n        );\n        assembly {\n            sstore(slot, receiver)\n        }\n    }\n\n    /**\n     * @dev Gets the royalty base points(percentage), for a particular token id, from storage slot.\n     * @return bp Royalty base points(percentage) for the royalty payouts of a specific token id.\n     */\n    function _getBp(uint256 tokenId) internal view returns (uint256 bp) {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.bp\", tokenId))) - 1\n        );\n        assembly {\n            bp := sload(slot)\n        }\n    }\n\n    /**\n     * @dev Sets the royalty base points(percentage), for a particular token id, to storage slot.\n     * @param tokenId Uint256 of the token id to set the base points for.\n     * @param bp Uint256 of royalty percentage, provided in base points format, for a particular token id.\n     */\n    function _setBp(uint256 tokenId, uint256 bp) internal {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.bp\", tokenId))) - 1\n        );\n        assembly {\n            sstore(slot, bp)\n        }\n    }\n\n    function _getPayoutAddresses() internal view returns (address payable[] memory addresses) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.addresses')) - 1);\n        bytes32 slot = 0xda9d0b1bc91e594968e30b896be60318d483303fc3ba08af8ac989d483bdd7ca;\n        uint256 length;\n        assembly {\n            length := sload(slot)\n        }\n        addresses = new address payable[](length);\n        address payable value;\n        for (uint256 i = 0; i < length; i++) {\n            slot = keccak256(abi.encodePacked(i, slot));\n            assembly {\n                value := sload(slot)\n            }\n            addresses[i] = value;\n        }\n    }\n\n    function _setPayoutAddresses(address payable[] memory addresses) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.addresses')) - 1);\n        bytes32 slot = 0xda9d0b1bc91e594968e30b896be60318d483303fc3ba08af8ac989d483bdd7ca;\n        uint256 length = addresses.length;\n        assembly {\n            sstore(slot, length)\n        }\n        address payable value;\n        for (uint256 i = 0; i < length; i++) {\n            slot = keccak256(abi.encodePacked(i, slot));\n            value = addresses[i];\n            assembly {\n                sstore(slot, value)\n            }\n        }\n    }\n\n    function _getPayoutBps() internal view returns (uint256[] memory bps) {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.bps')) - 1);\n        bytes32 slot = 0x7862b872ab9e3483d8176282b22f4ac86ad99c9035b3f794a541d84a66004fa2;\n        uint256 length;\n        assembly {\n            length := sload(slot)\n        }\n        bps = new uint256[](length);\n        uint256 value;\n        for (uint256 i = 0; i < length; i++) {\n            slot = keccak256(abi.encodePacked(i, slot));\n            assembly {\n                value := sload(slot)\n            }\n            bps[i] = value;\n        }\n    }\n\n    function _setPayoutBps(uint256[] memory bps) internal {\n        // The slot hash has been precomputed for gas optimizaion\n        // bytes32 slot = bytes32(uint256(keccak256('eip1967.PA1D.payout.bps')) - 1);\n        bytes32 slot = 0x7862b872ab9e3483d8176282b22f4ac86ad99c9035b3f794a541d84a66004fa2;\n        uint256 length = bps.length;\n        assembly {\n            sstore(slot, length)\n        }\n        uint256 value;\n        for (uint256 i = 0; i < length; i++) {\n            slot = keccak256(abi.encodePacked(i, slot));\n            value = bps[i];\n            assembly {\n                sstore(slot, value)\n            }\n        }\n    }\n\n    function _getTokenAddress(string memory tokenName)\n        internal\n        view\n        returns (address tokenAddress)\n    {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.tokenAddress\", tokenName))) - 1\n        );\n        assembly {\n            tokenAddress := sload(slot)\n        }\n    }\n\n    function _setTokenAddress(string memory tokenName, address tokenAddress) internal {\n        bytes32 slot = bytes32(\n            uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.tokenAddress\", tokenName))) - 1\n        );\n        assembly {\n            sstore(slot, tokenAddress)\n        }\n    }\n\n    /**\n     * @dev Internal function that transfers ETH to all payout recipients.\n     */\n    function _payoutEth() internal {\n        address payable[] memory addresses = _getPayoutAddresses();\n        uint256[] memory bps = _getPayoutBps();\n        uint256 length = addresses.length;\n        // accommodating the 2300 gas stipend\n        // adding 1x for each item in array to accomodate rounding errors\n        uint256 gasCost = (23300 * length) + length;\n        uint256 balance = address(this).balance;\n        require(balance - gasCost > 10000, \"PA1D: Not enough ETH to transfer\");\n        balance = balance - gasCost;\n        uint256 sending;\n        for (uint256 i = 0; i < length; i++) {\n            sending = ((bps[i] * balance) / 10000);\n            addresses[i].transfer(sending);\n        }\n    }\n\n    /**\n     * @dev Internal function that transfers tokens to all payout recipients.\n     * @param tokenAddress Smart contract address of ERC20 token.\n     */\n    function _payoutToken(address tokenAddress) internal {\n        address payable[] memory addresses = _getPayoutAddresses();\n        uint256[] memory bps = _getPayoutBps();\n        uint256 length = addresses.length;\n        IERC20 erc20 = IERC20(tokenAddress);\n        uint256 balance = erc20.balanceOf(address(this));\n        require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n        uint256 sending;\n        //uint256 sent;\n        for (uint256 i = 0; i < length; i++) {\n            sending = ((bps[i] * balance) / 10000);\n            require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n        }\n    }\n\n    /**\n     * @dev Internal function that transfers multiple tokens to all payout recipients.\n     * @dev Try to use _payoutToken and handle each token individually.\n     * @param tokenAddresses Array of smart contract addresses of ERC20 tokens.\n     */\n    function _payoutTokens(address[] memory tokenAddresses) internal {\n        address payable[] memory addresses = _getPayoutAddresses();\n        uint256[] memory bps = _getPayoutBps();\n        IERC20 erc20;\n        uint256 balance;\n        uint256 sending;\n        for (uint256 t = 0; t < tokenAddresses.length; t++) {\n            erc20 = IERC20(tokenAddresses[t]);\n            balance = erc20.balanceOf(address(this));\n            require(balance > 10000, \"PA1D: Not enough tokens to transfer\");\n            for (uint256 i = 0; i < addresses.length; i++) {\n                sending = ((bps[i] * balance) / 10000);\n                require(erc20.transfer(addresses[i], sending), \"PA1D: Couldn't transfer token\");\n            }\n        }\n    }\n\n    /**\n     * @dev This function validates that the call is being made by an authorised wallet.\n     * @dev Will revert entire tranaction if it fails.\n     */\n    function _validatePayoutRequestor() internal view {\n        if (!isOwner()) {\n            bool matched;\n            address payable[] memory addresses = _getPayoutAddresses();\n            address payable sender = payable(msg.sender);\n            for (uint256 i = 0; i < addresses.length; i++) {\n                if (addresses[i] == sender) {\n                    matched = true;\n                    break;\n                }\n            }\n            require(matched, \"PA1D: sender not authorized\");\n        }\n    }\n\n    /**\n     * @notice Set the wallets and percentages for royalty payouts.\n     * @dev Function can only we called by owner, admin, or identity wallet.\n     * @dev Addresses and bps arrays must be equal length. Bps values added together must equal 10000 exactly.\n     * @param addresses An array of all the addresses that will be receiving royalty payouts.\n     * @param bps An array of the percentages that each address will receive from the royalty payouts.\n     */\n    function configurePayouts(address payable[] memory addresses, uint256[] memory bps)\n        public\n        onlyOwner\n    {\n        require(addresses.length == bps.length, \"PA1D: missmatched array lenghts\");\n        uint256 totalBp;\n        for (uint256 i = 0; i < addresses.length; i++) {\n            totalBp = totalBp + bps[i];\n        }\n        require(totalBp == 10000, \"PA1D: bps down't equal 10000\");\n        _setPayoutAddresses(addresses);\n        _setPayoutBps(bps);\n    }\n\n    /**\n     * @notice Show the wallets and percentages of payout recipients.\n     * @dev These are the recipients that will be getting royalty payouts.\n     * @return addresses An array of all the addresses that will be receiving royalty payouts.\n     * @return bps An array of the percentages that each address will receive from the royalty payouts.\n     */\n    function getPayoutInfo()\n        public\n        view\n        returns (address payable[] memory addresses, uint256[] memory bps)\n    {\n        addresses = _getPayoutAddresses();\n        bps = _getPayoutBps();\n    }\n\n    /**\n     * @notice Get payout of all ETH in smart contract.\n     * @dev Distribute all the ETH(minus gas fees) to payout recipients.\n     */\n    function getEthPayout() public {\n        _validatePayoutRequestor();\n        _payoutEth();\n    }\n\n    /**\n     * @notice Get payout for a specific token address. Token must have a positive balance!\n     * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n     * @param tokenAddress An address of the token for which to issue payouts for.\n     */\n    function getTokenPayout(address tokenAddress) public {\n        _validatePayoutRequestor();\n        _payoutToken(tokenAddress);\n    }\n\n    /**\n     * @notice Get payout for a specific token name. Token must have a positive balance!\n     * @dev Contract owner, admin, identity wallet, and payout recipients can call this function.\n     * @dev Avoid using this function at all costs, due to high gas usage, and no guarantee for token support.\n     * @param tokenName A string of the token name for which to issue payouts for.\n     */\n    function getTokenPayoutByName(string memory tokenName) public {\n        _validatePayoutRequestor();\n        address tokenAddress = PA1D(payable(getRegistry().getPA1D())).getTokenAddress(tokenName);\n        require(!Address.isZero(tokenAddress), \"PA1D: Token address not found\");\n        _payoutToken(tokenAddress);\n    }\n\n    /**\n     * @notice Get payouts for tokens listed by address. Tokens must have a positive balance!\n     * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n     * @param tokenAddresses An address array of tokens to issue payouts for.\n     */\n    function getTokensPayout(address[] memory tokenAddresses) public {\n        _validatePayoutRequestor();\n        _payoutTokens(tokenAddresses);\n    }\n\n    /**\n     * @notice Get payouts for tokens listed by name. Tokens must have a positive balance!\n     * @dev Each token balance must be equal or greater than 10000. Otherwise calculating BP is difficult.\n     * @dev Avoid using this function at all costs, due to high gas usage, and no guarantee for token support.\n     * @param tokenNames A string array of token names to issue payouts for.\n     */\n    function getTokensPayoutByName(string[] memory tokenNames) public {\n        _validatePayoutRequestor();\n        uint256 length = tokenNames.length;\n        address[] memory tokenAddresses = new address[](length);\n        for (uint256 i = 0; i < length; i++) {\n            address tokenAddress = PA1D(payable(getRegistry().getPA1D())).getTokenAddress(\n                tokenNames[i]\n            );\n            require(!Address.isZero(tokenAddress), \"PA1D: Token address not found\");\n            tokenAddresses[i] = tokenAddress;\n        }\n        _payoutTokens(tokenAddresses);\n    }\n\n    /**\n     * @notice Inform about supported interfaces(eip-165).\n     * @dev Provides the supported interface ids that this contract implements.\n     * @param interfaceId Bytes4 of the interface, derived through bytes4(keccak256('sampleFunction(uin256,address)')).\n     * @return True if function is supported/implemented, false if not.\n     */\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\n        if (\n            // EIP2981\n            // bytes4(keccak256('royaltyInfo(uint256,uint256)')) == 0x2a55205a\n            interfaceId == 0x2a55205a ||\n            // Rarible V1\n            // bytes4(keccak256('getFeeBps(uint256)')) == 0xb7799584\n            interfaceId == 0xb7799584 ||\n            // Rarible V1\n            // bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\n            interfaceId == 0xb9c4d9fb ||\n            // Manifold\n            // bytes4(keccak256('getRoyalties(uint256)')) == 0xbb3bafd6\n            interfaceId == 0xbb3bafd6 ||\n            // Foundation\n            // bytes4(keccak256('getFees(uint256)')) == 0xd5a06d4c\n            interfaceId == 0xd5a06d4c ||\n            // SuperRare\n            // bytes4(keccak256('tokenCreator(address,uint256)')) == 0xb85ed7e4\n            interfaceId == 0xb85ed7e4 ||\n            // SuperRare\n            // bytes4(keccak256('calculateRoyaltyFee(address,uint256,uint256)')) == 0x860110f5\n            interfaceId == 0x860110f5 ||\n            // Zora\n            // bytes4(keccak256('marketContract()')) == 0xa1794bcd\n            interfaceId == 0xa1794bcd ||\n            // Zora\n            // bytes4(keccak256('tokenCreators(uint256)')) == 0xe0fd045f\n            interfaceId == 0xe0fd045f ||\n            // Zora\n            // bytes4(keccak256('bidSharesForToken(uint256)')) == 0xf9ce0582\n            interfaceId == 0xf9ce0582\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @notice Set the royalty information for entire contract, or a specific token.\n     * @dev Take great care to not make this function accessible by other public functions in your overlying smart contract.\n     * @param tokenId Set a specific token id, or leave at 0 to set as default parameters.\n     * @param receiver Wallet or smart contract that will receive the royalty payouts.\n     * @param bp Uint256 of royalty percentage, provided in base points format.\n     */\n    function setRoyalties(\n        uint256 tokenId,\n        address payable receiver,\n        uint256 bp\n    ) public onlyOwner {\n        if (tokenId == 0) {\n            _setDefaultReceiver(receiver);\n            _setDefaultBp(bp);\n        } else {\n            _setReceiver(tokenId, receiver);\n            _setBp(tokenId, bp);\n        }\n        address[] memory receivers = new address[](1);\n        receivers[0] = address(receiver);\n        uint256[] memory bps = new uint256[](1);\n        bps[0] = bp;\n        emit SecondarySaleFees(tokenId, receivers, bps);\n    }\n\n    // IEIP2981\n    function royaltyInfo(uint256 tokenId, uint256 value) public view returns (address, uint256) {\n        if (_getReceiver(tokenId) == address(0)) {\n            return (_getDefaultReceiver(), (_getDefaultBp() * value) / 10000);\n        } else {\n            return (_getReceiver(tokenId), (_getBp(tokenId) * value) / 10000);\n        }\n    }\n\n    // Rarible V1\n    function getFeeBps(uint256 tokenId) public view returns (uint256[] memory) {\n        uint256[] memory bps = new uint256[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            bps[0] = _getDefaultBp();\n        } else {\n            bps[0] = _getBp(tokenId);\n        }\n        return bps;\n    }\n\n    // Rarible V1\n    function getFeeRecipients(uint256 tokenId) public view returns (address payable[] memory) {\n        address payable[] memory receivers = new address payable[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            receivers[0] = _getDefaultReceiver();\n        } else {\n            receivers[0] = _getReceiver(tokenId);\n        }\n        return receivers;\n    }\n\n    // Manifold\n    function getRoyalties(uint256 tokenId)\n        public\n        view\n        returns (address payable[] memory, uint256[] memory)\n    {\n        address payable[] memory receivers = new address payable[](1);\n        uint256[] memory bps = new uint256[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            receivers[0] = _getDefaultReceiver();\n            bps[0] = _getDefaultBp();\n        } else {\n            receivers[0] = _getReceiver(tokenId);\n            bps[0] = _getBp(tokenId);\n        }\n        return (receivers, bps);\n    }\n\n    // Foundation\n    function getFees(uint256 tokenId)\n        public\n        view\n        returns (address payable[] memory, uint256[] memory)\n    {\n        address payable[] memory receivers = new address payable[](1);\n        uint256[] memory bps = new uint256[](1);\n        if (_getReceiver(tokenId) == address(0)) {\n            receivers[0] = _getDefaultReceiver();\n            bps[0] = _getDefaultBp();\n        } else {\n            receivers[0] = _getReceiver(tokenId);\n            bps[0] = _getBp(tokenId);\n        }\n        return (receivers, bps);\n    }\n\n    // SuperRare\n    // Hint taken from Manifold's RoyaltyEngine(https://github.com/manifoldxyz/royalty-registry-solidity/blob/main/contracts/RoyaltyEngineV1.sol)\n    // To be quite honest, SuperRare is a closed marketplace. They're working on opening it up but looks like they want to use private smart contracts.\n    // We'll just leave this here for just in case they open the flood gates.\n    function tokenCreator(\n        address, /* contractAddress*/\n        uint256 tokenId\n    ) public view returns (address) {\n        address receiver = _getReceiver(tokenId);\n        if (receiver == address(0)) {\n            return _getDefaultReceiver();\n        }\n        return receiver;\n    }\n\n    // SuperRare\n    function calculateRoyaltyFee(\n        address, /* contractAddress */\n        uint256 tokenId,\n        uint256 amount\n    ) public view returns (uint256) {\n        if (_getReceiver(tokenId) == address(0)) {\n            return (_getDefaultBp() * amount) / 10000;\n        } else {\n            return (_getBp(tokenId) * amount) / 10000;\n        }\n    }\n\n    // Zora\n    // we indicate that this contract operates market functions\n    function marketContract() public view returns (address) {\n        return address(this);\n    }\n\n    // Zora\n    // we indicate that the receiver is the creator, to convince the smart contract to pay\n    function tokenCreators(uint256 tokenId) public view returns (address) {\n        address receiver = _getReceiver(tokenId);\n        if (receiver == address(0)) {\n            return _getDefaultReceiver();\n        }\n        return receiver;\n    }\n\n    // Zora\n    // we provide the percentage that needs to be paid out from the sale\n    function bidSharesForToken(uint256 tokenId)\n        public\n        view\n        returns (Zora.BidShares memory bidShares)\n    {\n        // this information is outside of the scope of our\n        bidShares.prevOwner.value = 0;\n        bidShares.owner.value = 0;\n        if (_getReceiver(tokenId) == address(0)) {\n            bidShares.creator.value = _getDefaultBp();\n        } else {\n            bidShares.creator.value = _getBp(tokenId);\n        }\n        return bidShares;\n    }\n\n    /**\n     * @notice Get the storage slot for given string\n     * @dev Convert a string to a bytes32 storage slot\n     * @param slot The string name of storage slot(without the 'eip1967.PA1D.' prefix)\n     * @return A bytes32 reference to the storage slot\n     */\n    function getStorageSlot(string calldata slot) public pure returns (bytes32) {\n        return bytes32(uint256(keccak256(abi.encodePacked(\"eip1967.PA1D.\", slot))) - 1);\n    }\n\n    /**\n     * @notice Get the smart contract address of a token by common name.\n     * @dev Used only to identify really major/common tokens. Avoid using due to gas usages.\n     * @param tokenName The ticker symbol of the token. For example \"USDC\" or \"DAI\".\n     * @return The smart contract address of the token ticker symbol. Or zero address if not found.\n     */\n    function getTokenAddress(string memory tokenName) public view returns (address) {\n        return _getTokenAddress(tokenName);\n    }\n\n    /**\n     * @notice Forwards unknown function call to the CXIP hotfixes smart contract(if present)\n     * @dev All unrecognized functions are delegated to hotfixes smart contract which can be utilized to deploy on-chain hotfixes\n     */\n    function _defaultFallback() internal {\n        /**\n         * @dev Very important to note the use of sha256 instead of keccak256 in this function. Since the registry is made to be front-facing and user friendly, the choice to use sha256 was made due to the accessibility of that function in comparison to keccak.\n         */\n        address _target = getRegistry().getCustomSource(\n            sha256(abi.encodePacked(\"eip1967.CXIP.hotfixes\"))\n        );\n\n        /**\n         * @dev To minimize gas usage, pre-calculate the 32 byte hash and provide the final hex string instead of running the sha256 function on each call inside the smart contract\n         */\n        // address _target = getRegistry().getCustomSource(0x45f5c3bc3dbabbfab15d44af18b96716cf5bec748c58d54d61c4e7293de6763e);\n        /**\n         * @dev Assembly is used to minimize gas usage and pass the data directly through\n         */\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @notice Forwarding all unknown functions to default fallback\n     */\n    fallback() external {\n        _defaultFallback();\n    }\n\n    /**\n     * @dev This is intentionally left empty, to make sure that ETH transfers succeed.\n     */\n    receive() external payable {}\n}\n"
    },
    "contracts/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface IERC20 {\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/interface/ICxipERC.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\ninterface ICxipERC {\n    function admin() external view returns (address);\n\n    function isAdmin() external view returns (bool);\n\n    function isOwner() external view returns (bool);\n\n    function isOwner(address wallet) external view returns (bool);\n\n    function name() external view returns (string memory);\n\n    function owner() external view returns (address);\n\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n\n    function symbol() external view returns (string memory);\n}\n"
    },
    "contracts/proxy/PA1DProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract PA1DProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da).getPA1DSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipProvenanceProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipProvenanceProxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da)\n            .getProvenanceSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipERC721Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipERC721Proxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da)\n            .getERC721CollectionSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/proxy/CxipERC1155Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.12;\n\n/*______/\\\\\\\\\\\\\\\\\\__/\\\\\\_______/\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\\\\\___\n _____/\\\\\\////////__\\///\\\\\\___/\\\\\\/__\\/////\\\\\\///__\\/\\\\\\/////////\\\\\\_\n  ___/\\\\\\/_____________\\///\\\\\\\\\\\\/________\\/\\\\\\_____\\/\\\\\\_______\\/\\\\\\_\n   __/\\\\\\_________________\\//\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\\\\\\\\\\\\\\\\\\\\\/__\n    _\\/\\\\\\__________________\\/\\\\\\\\__________\\/\\\\\\_____\\/\\\\\\/////////____\n     _\\//\\\\\\_________________/\\\\\\\\\\\\_________\\/\\\\\\_____\\/\\\\\\_____________\n      __\\///\\\\\\_____________/\\\\\\////\\\\\\_______\\/\\\\\\_____\\/\\\\\\_____________\n       ____\\////\\\\\\\\\\\\\\\\\\__/\\\\\\/___\\///\\\\\\__/\\\\\\\\\\\\\\\\\\\\\\_\\/\\\\\\_____________\n        _______\\/////////__\\///_______\\///__\\///////////__\\///____________*/\n\nimport \"../interface/ICxipRegistry.sol\";\n\ncontract CxipERC1155Proxy {\n    fallback() external payable {\n        address _target = ICxipRegistry(0x415225c0d082CB195AeE69f490c218def30966da)\n            .getERC1155CollectionSource();\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), _target, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 100
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}